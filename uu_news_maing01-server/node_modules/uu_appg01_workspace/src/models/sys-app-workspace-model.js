"use strict";

const Path = require("path");
const Lru = require("lru-cache");
const { Config } = require("uu_appg01_core-utils");
const { Validator } = require("uu_appg01_core-validation");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { DaoFactory, ObjectStoreError } = require("uu_appg01_objectstore");
const { ValidationHelper } = require("uu_appg01_core-appserver");

const ProfileConfig = require("../helpers/profile-config.js");
const SysAppWorkspaceConfig = require("./sys-app-workspace-config-model.js");
const SysDataStoreStats = require("./sys-data-store-stats-model");

const { AppClient } = require("uu_appg01_core-appclient");
const { UriBuilder } = require("uu_appg01_core-uri");
const { AuthorizationService } = require("uu_appg01_core-authorization");
const SysAppRuntimeModeModel = require("./sys-app-runtime-mode-model");
const appClientTokenService = require("./../app-client-token-service");

const Errors = require("../errors/sys-app-workspace-errors.js");
const AppClientTokenErrors = require("../errors/sys-app-client-token-errors");
const OidcClientHelper = require("../helpers/oidc-client-helper");

/**
 * represent sysAppWorkspace collection in the database
 * and store information about workspace
 */
class SysAppWorkspaceModel {

  constructor() {
    this.VERSION = "1.0";
    this.INITIALIZING_STATE = "initializing";
    this.INITIALIZED_STATE = "initialized";
    this.DEFAULT_SERVICE_NAME = "uu_appg01_workspace";
    this.ART_AUTHZ_TYPE = "artifact";
    this.DEFAULT_AUTHZ_TYPE = "roleGroupInterface";
    this.DEFAULT_RUNTIME_MODE = "standard";

    // Initialize cache with TTL 5 minutes
    this.sysAppCache = new Lru({ maxAge: 1000 * 60 * 5 });
    this.validator = Validator.load();
    this.dao = DaoFactory.getDao("sysAppWorkspace");
    this.logger = LoggerFactory.get("uuapp.workspace.SysAppWorkspaceModel");
  }

  /**
   * create empty collection with indexes
   * @returns {Promise<void>}
   */
  async createSchema() {
    await this.dao.createSchema();
  }

  /**
   * initialize new workspace
   * create sysAppWorkspace, sysAppWorkspaceConfig, sysPermission and sysProfile collections
   * and fill them with initialize values like profiles from profiles.json
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<{}>}
   */
  async initAppWorkspace(dtoIn, uuAppErrorMap = {}) {
    const SysPermission = require("./sys-permission-model");
    const SysProfile = require("./sys-profile-model");

    let validationResult = this.validator.validate("sysInitAppWorkspaceDtoInType", dtoIn);

    //HDS 1, A1, A2
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SysInitAppWorkspace.UC_CODE}unsupportedKeys`,
      Errors.SysInitAppWorkspace.InvalidDtoInError
    );

    let awid = dtoIn["awid"];
    let profileCodes = ProfileConfig.getProfiles();

    dtoIn["profileList"] = profileCodes;
    dtoIn["version"] = this.VERSION;
    dtoIn["state"] = this.INITIALIZING_STATE;
    dtoIn["authorizationStrategy"] = this.DEFAULT_AUTHZ_TYPE;
    if (!dtoIn["runtimeMode"]) {
      dtoIn["runtimeMode"] = { mode: this.DEFAULT_RUNTIME_MODE };
    }

    let uuObject = dtoIn;
    let asid = Config.get("asid");

    //A3
    if (asid === dtoIn["awid"]) {
      throw new Errors.SysInitAppWorkspace.AwidConflictsWithAsidError(
        { uuAppErrorMap },
        {
          awid: dtoIn["awid"],
          asid: asid
        }
      );
    }

    let appWorkspace = await this.dao.getByAwid(awid);

    if (appWorkspace) {
      //HDS 2, A4
      if (appWorkspace["state"] === this.INITIALIZED_STATE) {
        throw new Errors.SysInitAppWorkspace.AwidNotUniqueError({ uuAppErrorMap }, { state: appWorkspace["state"] });
      }

      try {
        await SysAppWorkspaceConfig.remove(awid);
      } catch (e) {
        //A11
        if (e instanceof ObjectStoreError) {
          throw new Errors.SysInitAppWorkspace.SysAppWorkspaceConfigDaoDeleteByAwidFailedError({ uuAppErrorMap }, e);
        }
        throw e;
      }

      try {
        await SysProfile.deleteAllProfiles(awid);
      } catch (e) {
        //A12
        if (e instanceof ObjectStoreError) {
          throw new Errors.SysInitAppWorkspace.SysProfileDaoDeleteByAwidFailedError({ uuAppErrorMap }, e);
        }
        throw e;
      }

      try {
        await this.delete(awid);
      } catch (e) {
        //A13
        if (e instanceof ObjectStoreError) {
          throw new Errors.SysInitAppWorkspace.SysAppWorkspaceDaoDeleteByAwidFailedError({ uuAppErrorMap }, e);
        }
        throw e;
      }
    }

    //HDS 3
    try {
      await Promise.all([
        this.createSchema(),
        SysPermission.createSchema(),
        SysAppWorkspaceConfig.createSchema(),
        SysProfile.createSchema(),
        SysDataStoreStats.createSchema()
      ]);
    } catch (e) {
      //A5
      if (e instanceof ObjectStoreError) {
        throw new Errors.SysInitAppWorkspace.CreateSchemaFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    }

    try {
      //HDS 4, A6
      appWorkspace = await this.create(uuObject);
    } catch (e) {
      //A7
      if (e instanceof ObjectStoreError) {
        throw new Errors.SysInitAppWorkspace.SysAppWorkspaceDaoCreateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    }

    //HDS 5
    try {
      await SysProfile.initProfiles(awid, profileCodes);
    } catch (e) {
      //A8
      if (e instanceof ObjectStoreError) {
        throw new Errors.SysInitAppWorkspace.SysProfileDaoCreateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    }

    let config = {
      awid: awid
    };

    //HDS 6
    try {
      await SysAppWorkspaceConfig.create(config);
    } catch (e) {
      //A9
      if (e instanceof ObjectStoreError) {
        throw new Errors.SysInitAppWorkspace.SysAppWorkspaceConfigDaoCreateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    }

    //HDS 7
    try {
      await SysDataStoreStats.create(awid);
    } catch (e) {
      //A14
      throw new Errors.SysInitAppWorkspace.SysAppWorkspaceDataStoreStatsDaoCreateFailedError({ uuAppErrorMap }, e);
    }

    //HDS 8
    try {
      appWorkspace["state"] = this.INITIALIZED_STATE;
      await this.dao.update(appWorkspace);
    } catch (e) {
      //A10
      if (e instanceof ObjectStoreError) {
        throw new Errors.SysInitAppWorkspace.SysAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    }

    //HDS 9
    await OidcClientHelper.initOidcClient(awid, uuAppErrorMap, this.logger);

    //HDS 10
    let dtoOut = {};
    dtoOut["uuAppErrorMap"] = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * return licenseOwner information
   * @param {String} awid
   * @param {Object} uuAppErrorMap
   * @returns {Promise<{}>}
   */
  async getLicenseOwner(awid, uuAppErrorMap = {}) {
    //HDS1 A1,A2
    let appWorkspace;
    try {
      appWorkspace = await this.get(awid, uuAppErrorMap);
    } catch (e) {
      throw new Errors.SysGetLicenseOwner.SysAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
    }

    //HDS2
    let license = {};
    license["awid"] = appWorkspace["awid"];

    if (appWorkspace["licenseOwner"] && appWorkspace["licenseOwner"]["organization"]) {
      license["organization"] = appWorkspace["licenseOwner"]["organization"];
    }

    license["userList"] = appWorkspace["licenseOwner"]["userList"];
    license["uuAppErrorMap"] = uuAppErrorMap;

    //HDS3
    return license;
  }

  /**
   * return workspace information from database
   * @param {Object} uri
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<void>}
   */
  async getAppWorkspace(uri, dtoIn, uuAppErrorMap = {}) {
    let self = this;
    let validationResult;
    let isPrivileged;

    isPrivileged = ProfileConfig.isPrivilegedCall(uri.getAwid());

    let awid;

    //HDS 1, A1
    if (isPrivileged) {
      awid = dtoIn["awid"];

      //HDS 2, A1, A2
      validationResult = self.validator.validate("sysGetAppWorkspaceDtoInType", dtoIn);
      uuAppErrorMap = ValidationHelper.processValidationResult(
        dtoIn,
        validationResult,
        `${Errors.SysGetAppWorkspace.UC_CODE}unsupportedKeys`,
        Errors.SysGetAppWorkspace.InvalidDtoInError
      );
    } else {
      dtoIn = undefined;
      awid = uri.getAwid();
    }

    //HDS 3, A4, A5
    let appWorkspace = await this.get(awid);
    delete appWorkspace["awid"];

    appWorkspace["uuAppErrorMap"] = uuAppErrorMap;

    //HDS 4
    return appWorkspace;
  }

  async deleteAppWorkspace(uri, dtoIn) {
    //HDS 1, A1, A2
    let validationResult = this.validator.validate("sysDeleteAppWorkspaceDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SysDeleteAppWorkspace.UC_CODE}unsupportedKeys`,
      Errors.SysDeleteAppWorkspace.InvalidDtoInError
    );

    //HDS 2, A3
    let awid = dtoIn["awid"];
    let sysAppWorkspace;
    try {
      sysAppWorkspace = await this.getAppWorkspace(uri, { awid });
    } catch (e) {
      if (e instanceof Errors.SysGetAppWorkspace.SysAppWorkspaceDoesNotExistError) {
        throw new Errors.SysDeleteAppWorkspace.SysAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
      throw e;
    }

    //HDS 3, A4
    if (sysAppWorkspace.artifactUri) {
      throw new Errors.SysDeleteAppWorkspace.ArtifactConnectedToSysAppWorkspace(
        { uuAppErrorMap },
        {
          awid,
          artifactUri: sysAppWorkspace.artifactUri
        }
      );
    }

    //HDS 4
    if (sysAppWorkspace.state !== "closed") {
      throw new Errors.SysDeleteAppWorkspace.AwidNotClosed({ uuAppErrorMap }, { awid, state: sysAppWorkspace.state });
    }

    //HDS 5, 6
    for (let [schema, dao] of DaoFactory._daos.entries()) {
      let filter = { awid };
      let isBinary = Object.getPrototypeOf(dao.constructor).name === "UuBinaryDao";

      if (isBinary) {
        await this._executeDeleteBinary(dao, schema, filter);
      } else {
        await this._executeDeleteMany(dao, schema, filter);
      }
    }

    //HDS 7
    this.clearCache();
    SysAppWorkspaceConfig.clearCache();
    SysAppRuntimeModeModel.clearCache();
    return { uuAppErrorMap };
  }

  async setAuthorizationType(uri, dtoIn, session) {
    //HDS 1.1, 1.2, 1.3
    let validationResult = this.validator.validate("sysSetAuthTypeDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetAuthorizationType.UC_CODE}unsupportedKeys`,
      Errors.SetAuthorizationType.InvalidDtoInError
    );

    //HDS 2
    let appWorkspace = await this.dao.getByAwid(uri.awid);

    if (appWorkspace["state"] !== this.INITIALIZED_STATE) {
      throw new Errors.SetAuthorizationType.UuAppWorkspaceIsNotInProperStateError(
        { uuAppErrorMap },
        { state: appWorkspace["state"] }
      );
    }

    //HDS 3,4
    try {
      let authzSvc = AuthorizationService.get(this.DEFAULT_SERVICE_NAME);
      await authzSvc._authorizeUser(session, uri, dtoIn["authorizationStrategy"]);
    } catch (e) {
      throw new Errors.SetAuthorizationType.UserIsNotAuthorizedToChangeAuthStrategy(
        { uuAppErrorMap },
        {
          uuIdentity: session.identity._uuIdentity,
          authorizationStrategy: dtoIn["authorizationStrategy"]
        },
        e
      );
    }

    //HDS 5
    try {
      appWorkspace = await this.dao.updateByAwid(uri.awid, { authorizationStrategy: dtoIn["authorizationStrategy"] });
    } catch (e) {
      throw new Errors.SetAuthorizationType.SysAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, {}, e);
    }

    this.sysAppCache.set(appWorkspace["awid"], appWorkspace);
    appWorkspace = { ...appWorkspace, ...{ uuAppErrorMap } };

    //HDS 6
    return appWorkspace;
  }

  async connectArtifact(uri, dtoIn, session) {
    //HDS 1.1, 1.2, 1.3
    let validationResult = this.validator.validate("sysConnectArtifactDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.ConnectArtifact.UC_CODE}unsupportedKeys`,
      Errors.ConnectArtifact.InvalidDtoInError
    );

    //HDS 2
    let appWorkspace = await this.dao.getByAwid(uri.awid);
    if (appWorkspace["state"] !== this.INITIALIZED_STATE) {
      throw new Errors.ConnectArtifact.UuAppWorkspaceIsNotInProperStateError(
        { uuAppErrorMap },
        { state: appWorkspace["state"] }
      );
    }

    //HDS 3
    let callUriBuilder = UriBuilder.parse(dtoIn["artifactUri"]);
    callUriBuilder.setUseCase("uuAwsc/connectAppWorkspace");
    const callUri = callUriBuilder.toUri();

    let appClientToken;
    try {
      appClientToken = await appClientTokenService.createToken(uri, callUri);
    } catch (e) {
      if (e instanceof AppClientTokenErrors.GetPrivateKey.KeysNotInitialized) {
        throw new Errors.ConnectArtifact.TokenCreateFailed({ uuAppErrorMap }, e);
      }
      throw e;
    }

    //HDS 4
    if (dtoIn.synchronizeArtifactBasicAttributes == null) {
      dtoIn.synchronizeArtifactBasicAttributes = true;
    }

    let parameters = {
      id: callUri.getParameters().id,
      code: callUri.getParameters().code,
      uuAppWorkspaceUri: UriBuilder.parse(uri)
        .setUseCase(null)
        .toString(),
      synchronizeArtifactBasicAttributes: dtoIn.synchronizeArtifactBasicAttributes
    };

    let headers = {};
    headers["Authorization"] = await session.getCallToken(callUri);

    const callOpts = appClientTokenService.setToken({ headers }, appClientToken);

    try {
      await AppClient.post(callUri, parameters, callOpts);
    } catch (e) {
      throw new Errors.ConnectArtifact.UuCmdConnectAppWorkspaceCallFailedError({ uuAppErrorMap }, e);
    }

    //HDS 5
    let workspace = {
      artifactUri: dtoIn["artifactUri"],
      authorizationStrategy: this.ART_AUTHZ_TYPE
    };

    try {
      appWorkspace = await this.dao.updateByAwid(uri.awid, workspace);
    } catch (e) {
      throw new Errors.ConnectArtifact.SysAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
    }

    this.sysAppCache.set(appWorkspace["awid"], appWorkspace);

    appWorkspace = { ...appWorkspace, ...{ uuAppErrorMap } };

    //HDS 6
    return appWorkspace;
  }

  async setAppWorkspaceState(uri, dtoIn) {
    //HDS 1, A1, A2
    let validationResult = this.validator.validate("sysSetAppWorkspaceStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SysSetAppWorkspaceState.UC_CODE}unsupportedKeys`,
      Errors.SysSetAppWorkspaceState.InvalidDtoInError
    );

    let dtoOut;
    try {
      //HDS 2, A3, A4
      dtoOut = await this.dao.updateState(dtoIn["awid"], dtoIn["state"]);
    } catch (e) {
      if (e.code === "uu-app-objectstore/objectNotFound") {
        throw new Errors.SysSetAppWorkspaceState.SysAppWorkspaceDoesNotExist(
          { uuAppErrorMap },
          { awid: dtoIn["awid"] }
        );
      } else {
        throw new Errors.SysSetAppWorkspaceState.SysAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, e);
      }
    }

    this.clearCache();

    //HDS 3
    dtoOut["uuAppErrorMap"] = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * return workspace
   * @param {String} awid
   * @returns {Promise<*>}
   */
  async get(awid) {
    let appWorkspace = this.sysAppCache.get(awid);

    if (!appWorkspace) {
      appWorkspace = await this.dao.getByAwid(awid);

      if (!appWorkspace) {
        throw new Errors.SysGetAppWorkspace.SysAppWorkspaceDoesNotExistError(null, { awid });
      }
      this.addToCache(appWorkspace);
    }

    return appWorkspace;
  }

  /**
   * store workspace in the cache
   * @param {Object} appWorkspace
   */
  addToCache(appWorkspace) {
    this.sysAppCache.set(appWorkspace["awid"], appWorkspace);
  }

  /**
   * reset whole cache
   */
  clearCache() {
    this.sysAppCache.reset();
  }

  /**
   * return profileList stored in the workspace
   * @param {String} awid
   * @returns {Promise<void>}
   */
  async getAppWorkspaceProfiles(awid) {
    let appWorkspace = await this.get(awid);
    return appWorkspace["profileList"];
  }

  /**
   * check for NoaLimit and store workspace to the database
   * @param {Object} uuObject
   * @returns {Promise<*>}
   */
  async create(uuObject) {
    await this._checkNoa();
    return await this.dao.create(uuObject);
  }

  /**
   * delete workspace by awid and reset the cache
   * @param {String} awid
   * @returns {Promise<*>}
   */
  async delete(awid) {
    this.clearCache();
    return await this.dao.deleteByAwid(awid);
  }

  async setAwidRuntimeMode(awid, dtoIn) {
    //HDS 1, A1, A2
    let validationResult = this.validator.validate("sysSetAwidRuntimeModeDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SysSetAwidRuntimeMode.UC_CODE}unsupportedKeys`,
      Errors.SysSetAwidRuntimeMode.InvalidDtoInError
    );

    dtoIn["from"] = dtoIn["from"] || new Date().toISOString();

    //HDS 2, A3
    try {
      await this.dao.updateAwidRuntimeMode(awid, dtoIn);
    } catch (e) {
      throw new Errors.SysSetAwidRuntimeMode.SysAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, { awid }, e);
    }

    //HDS 3
    this.clearCache();

    //HDS 4
    return { uuAppErrorMap };
  }

  async getAwidRuntimeMode(awid) {
    let workspace;

    //HDS 1, A1, A2
    try {
      workspace = await this.get(awid);
    } catch (e) {
      throw new Errors.SysGetAwidRuntimeMode.SysAppWorkspaceDoesNotExist({ awid });
    }

    //HDS 2
    workspace.runtimeMode.uuAppErrorMap = {};
    return workspace.runtimeMode;
  }

  /**
   * check for Noa limit
   * @returns {Promise<void>}
   * @private
   */
  async _checkNoa() {
    let maxNoa = DaoFactory.getMaxNoa();
    let awidsCount = await this.dao.getCount();

    if (awidsCount >= maxNoa) {
      throw new Errors.MaximumNumberAwidsError(maxNoa);
    }
  }

  async _executeDeleteMany(dao, schema, filter) {
    // to avoid circular dependency
    const SysDumpRestoreModel = require("./sys-dump-restore-model");
    let dumbDao = SysDumpRestoreModel._getDumpDao(dao, schema);
    await dumbDao.deleteMany(filter);
  }

  async _executeDeleteBinary(dao, schema, filter) {
    // to avoid circular dependency
    const SysDumpRestoreModel = require("./sys-dump-restore-model");
    let dumbDao = SysDumpRestoreModel._getDumpDao(dao, schema);
    await dumbDao.deleteBinary(filter, schema);
  }

}

module.exports = new SysAppWorkspaceModel();
