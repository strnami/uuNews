"use strict";
const { Validator } = require("uu_appg01_core-validation");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { DaoFactory, Lock } = require("uu_appg01_objectstore");
const { LoggerFactory } = require("uu_appg01_core-logging");
const logger = LoggerFactory.get("uuapp.workspace.models.SysDataStoreStatsModel");
const { PersistenceConfig } = require("uu_appg01_datastore");

const Errors = require("../errors/sys-data-store-stats-errors");

const SySDataStoreStatsBsCalcMongoDb = require("../daos/sys-data-store-stats-bs-calc-mongo");
const SySDataStoreStatsOsCalcMongoDb = require("../daos/sys-data-store-stats-os-calc-mongo");

const UNCALCULATED_DATA_STORE_STATS = {
  size: 0,
  count: 0,
  calcStartTs: null,
  calcEndTs: null,
  dataStoreMap: {}
};

class SysDataStoreStatsModel {
  constructor() {
    this.CALCULATE_DEFAULTS = {
      calcLockDurationSec: 60,
      calcWriteLimitSec: 20,
      calcRecalculationLimitSec: 10 * 60
    };

    this.validator = Validator.load();
    this.dao = DaoFactory.getDao("sysDataStoreStats");
  }

  /**
   * create collection with indexes
   * @returns {Promise<void>}
   */
  async createSchema() {
    await this.dao.createSchema();
  }

  async create(awid) {
    await this.dao.create(this._getUncalculatedDataStoreStats(awid));
  }

  async getDataStoreStats(awid, dtoIn) {
    //HDS 1.1, 1.2, 1.3 A1 A2
    let validationResult = this.validator.validate("sysGetDataStoreStatsDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.GetDataStoreStats.UC_CODE}unsupportedKeys`,
      Errors.GetDataStoreStats.InvalidDtoInError
    );

    let now = new Date();
    let dtoOut;

    //HDS 2
    dtoOut = await this.dao.getByAwid(awid);

    //A3
    if (!dtoOut) {
      throw new Errors.GetDataStoreStats.StatsDoNotExist({ uuAppErrorMap });
    }

    //HDS 3.1, 3.2, 3.3, 3.4
    dtoOut["state"] = this._getCalculationState(dtoOut, now);
    dtoOut["uuAppErrorMap"] = uuAppErrorMap;
    return dtoOut;
  }

  async listDataStoreStats(dtoIn) {
    //HDS 1.1, 1.2, 1.3 A1 A2
    let validationResult = this.validator.validate("sysListDataStoreStatsDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.ListDataStoreStats.UC_CODE}unsupportedKeys`,
      Errors.ListDataStoreStats.InvalidDtoInError
    );

    let now = new Date();
    let dtoOut;

    //HDS 2.1, 2.2
    if (dtoIn["awidList"]) {
      dtoOut = await this.dao.listByAwids(dtoIn["awidList"], dtoIn["pageInfo"]);
    } else {
      dtoOut = await this.dao.list(dtoIn["pageInfo"]);
    }

    dtoOut["itemList"].forEach(item => {
      item["state"] = this._getCalculationState(item, now);
    });

    dtoOut["uuAppErrorMap"] = uuAppErrorMap;

    //HDS 3
    return dtoOut;
  }

  async calculateDataStoreStats(awid, dtoIn) {
    //HPS I.1.1, I.1.2, I.1.3 A1, A2
    let validationResult = this.validator.validate("sysCalculateDataStoreStatsDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.CalculateDataStoreStats.UC_CODE}unsupportedKeys`,
      Errors.CalculateDataStoreStats.InvalidDtoInError
    );

    let limits = this.CALCULATE_DEFAULTS;
    let lock = new Lock("dataStoreStatsCalc", limits.calcLockDurationSec);
    let stats;

    //HDS I.2 A3
    try {
      stats = await this.dao.lockByAwid(awid, lock);
    } catch (e) {
      if (e.code === "uu-app-objectstore/objectLocked") {
        throw new Errors.CalculateDataStoreStats.CalculationAlreadyInProgress({ uuAppErrorMap }, e);
      }
    }

    let now = new Date();
    stats["dataStoreMap"] = {};
    stats["awid"] = awid;

    let lastCalcStart = stats["calcStartTs"];
    let lastCalcEnd = stats["calcEndTs"];

    //HDS I.3
    if (lastCalcStart && (!lastCalcEnd || lastCalcStart > lastCalcEnd)) {
      ValidationHelper.addWarning(
        uuAppErrorMap,
        `uu-app-workspace-${Errors.CalculateDataStoreStats.PreviousCalculationFailed.code}`,
        Errors.CalculateDataStoreStats.PreviousCalculationFailed.message,
        {}
      );
    } else if (lastCalcEnd && now - lastCalcEnd < limits.calcRecalculationLimitSec) {
      if (!dtoIn["force"]) {
        try {
          await this.dao.unlockByAwid(awid, lock);
        } catch (e) {
          //A12
          throw new Errors.CalculateDataStoreStats.UnlockByDaoFailed({ uuAppErrorMap }, e);
        }
        throw new Errors.CalculateDataStoreStats.CalculatedRecently(
          { uuAppErrorMap },
          {
            calcEndTs: stats["calcEndTs"],
            limitSec: limits["calcRecalculatationLimitSec"]
          }
        );
      }
    }

    //HDS I.4
    stats["calcStartTs"] = now;
    stats["lastCalcError"] = null;
    try {
      await this.dao.updateByAwid(awid, stats, lock);
    } catch (e) {
      await this._unlockByAwidLogException(awid, lock);
      throw new Errors.CalculateDataStoreStats.UpdateByDaoFailed({ uuAppErrorMap }, e);
    }

    this._calculateDataStoreStatsAsync(stats, lock, uuAppErrorMap).catch(e => {
      logger.error(null, e);
    });

    return { uuAppErrorMap };
  }

  removeUnusedStats(stats) {
    Object.keys(stats.dataStoreMap).forEach(dataStoreName => {
      let dataStore = stats.dataStoreMap[dataStoreName];

      Object.keys(dataStore.schemaMap).forEach(schemaName => {
        let schema = dataStore.schemaMap[schemaName];
        if (schema["count"] === 0) {
          delete dataStore.schemaMap[schemaName];
        }
      });
      if (dataStore.schemaMap.size === 0) {
        delete stats.dataStoreMap;
      }
    });
  }

  async _calculateDataStoreStatsAsync(stats, lock, uuAppErrorMap) {
    let limits = this.CALCULATE_DEFAULTS;

    //HDS II.1
    let startTime = new Date();
    let lastWrite = startTime;
    let now = new Date();

    //HDS II.2
    let stores = this._loadDataStoresMap();

    //HDS II.3
    await lock.setExpiration(limits.calcLockDurationSec);

    //HDS II.4
    let promises = Array.from(Object.keys(stores)).map(async dataStoreName => {
      let dataStore = stores[dataStoreName];
      let calcDaoClass;

      //HDS II.4.1
      if (dataStore.type[0] === "uuAppObjectStore" && dataStore.type[1] === "MongoDB") {
        calcDaoClass = SySDataStoreStatsOsCalcMongoDb;
      } else if (dataStore.type[0] === "uuAppBinaryStore" && dataStore.type[1] === "MongoDB") {
        calcDaoClass = SySDataStoreStatsBsCalcMongoDb;
      } else {
        //A7
        throw new Errors.CalculateDataStoreStats.UnknownDataStoreType({ uuAppErrorMap }, { type: dataStore.type });
      }

      let calcDao;
      //HDS II.4.2.1
      try {
        calcDao = new calcDaoClass(dataStore.connectionString);
      } catch (e) {
        //throw error
      }

      let dataStoreStats = stats["dataStoreMap"][dataStore.name];

      if (!dataStoreStats) {
        dataStoreStats = {
          type: dataStore.type[0],
          count: 0,
          size: 0,
          schemaMap: {}
        };
        stats["dataStoreMap"][dataStore.name] = dataStoreStats;
      }

      //HDS II.4.2
      let promises = await Array.from(dataStore.schemaList).map(async schema => {
        let schemaStats;
        try {
          schemaStats = await calcDao.calculate(stats["awid"], schema);
        } catch (e) {
          throw new Errors.CalculateDataStoreStats.CurrentCalculationFailed({ uuAppErrorMap }, { cause: e });
        }

        //HDS II.4.2.1.1
        await lock.setExpiration(limits.calcLockDurationSec);

        //HDS II.4.2.1.2
        now = new Date();
        schemaStats["ts"] = now;

        schemaStats["size"] = Math.ceil(schemaStats["size"]);
        dataStoreStats["schemaMap"][schema] = schemaStats;
        stats["dataStoreMap"][dataStore.name] = dataStoreStats;

        //HDS II.4.2.1.3
        let lastSchema = schema === dataStore.schemaList[dataStore.schemaList.length - 1];
        if (now - lastWrite > limits["calcWriteLimitSec"] || lastSchema) {
          //HDS II.4.2.1.3.1
          this._recalculateTotals(stats);

          //HDS II.4.2.1.3.2
          await this._updateStats(stats, lock, uuAppErrorMap);

          //HDS II.4.2.1.3.3
          lastWrite = now;
        }
      });

      await Promise.all(promises);

      //HDS II.5, II.6
      this.removeUnusedStats(stats);

      //HDS II.7
      this._recalculateTotals(stats);

      //HDS II.8
      stats["calcEndTs"] = new Date();

      await this._updateStats(stats, lock, uuAppErrorMap);
    });

    try {
      await Promise.all(promises);
    } catch (e) {
      // A10
      await this._updateByAwidLogException(
        stats["awid"],
        {
          lastCalcError: {
            msg: e.toString(),
            paramMap: e.paramMap
          }
        },
        lock
      );
      await this._unlockByAwidLogException(stats["awid"], lock);
    }

    try {
      await this.dao.unlockByAwid(stats["awid"], lock);
    } catch (e) {
      throw new Errors.CalculateDataStoreStats.UnlockByDaoFailed({ uuAppErrorMap }, { cause: e });
    }

    logger.info(
      `${stats["awid"]} - Data store stats calculation finished without any error in ${Math.abs(
        new Date().getTime() - startTime.getTime()
      ) / 1000} seconds.`
    );
  }

  _recalculateTotals(stats) {
    stats["count"] = 0;
    stats["size"] = 0;
    Object.keys(stats.dataStoreMap).forEach(dataStoreName => {
      let dataStore = stats.dataStoreMap[dataStoreName];
      dataStore["count"] = 0;
      dataStore["size"] = 0;
      Object.keys(dataStore.schemaMap).forEach(schemaName => {
        let schema = dataStore.schemaMap[schemaName];
        dataStore["count"] += schema["count"];
        dataStore["size"] += schema["size"];
        stats["count"] += schema["count"];
        stats["size"] += schema["size"];
      });
    });
  }

  async _updateStats(stats, lock, uuAppErrorMap) {
    try {
      await this.dao.updateByAwid(stats["awid"], stats, lock);
    } catch (e) {
      throw new Errors.CalculateDataStoreStats.UpdateByDaoFailed({ uuAppErrorMap }, e);
    }
  }

  /**
   * load data from all persistence.json and schema_realizations files
   * and connection string for these stores for statistics
   * @returns {*[]}
   * @private
   */
  _loadDataStoresMap() {
    const { schemas, dataStores } = PersistenceConfig;

    let realizationStructure = {
    };

    schemas.forEach((schema, schemaName) => {
      const storeName = schema.dataStore;
      if (!realizationStructure[storeName]) {
        const store = dataStores.get(storeName);
        realizationStructure[storeName] = {
          name: storeName,
          type: [store.type, store.realization],
          connectionString: store.connectionString,
          schemaList: []
        };
      }
      let schemaList = realizationStructure[storeName]["schemaList"];
      realizationStructure[storeName]["schemaList"] = schemaList.concat(schemaName);
    });

    return Object.values(realizationStructure);
  }

  _getCalculationState(stats, now) {
    let lockExpiration = stats["sys"]["lockExpTs"];
    let result;

    if (lockExpiration) {
      result = lockExpiration >= now ? "running" : "failed";
    } else if (stats["calcStartTs"] == null) {
      result = "neverCalculated";
    } else if (stats["calcStartTs"] != null && stats["calcStartTs"] < stats["calcEndTs"]) {
      result = "completed";
    } else {
      result = "failed";
    }

    return result;
  }

  async _unlockByAwidLogException(awid, lock) {
    try {
      await this.dao.unlockByAwid(awid, lock);
    } catch (e) {
      logger.error(null, e);
    }
  }

  async _updateByAwidLogException(awid, stats, lock) {
    try {
      await this.dao.updateByAwid(awid, stats, lock);
    } catch (e) {
      logger.error(null, e);
    }
  }

  _getUncalculatedDataStoreStats(awid) {
    return Object.assign({ awid }, UNCALCULATED_DATA_STORE_STATS);
  }
}

module.exports = new SysDataStoreStatsModel();
