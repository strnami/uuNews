const BaseConfig = require("./base-config.js");
const { Validator } = require("uu_appg01_core-validation");
const Path = require("path");
const { Config } = require("uu_appg01_core-utils");
const { InvalidKeyError } = require("../errors/startup-errors.js");
const { mergeProfiles } = require("./profile-merger.js");

const PROFILES_CONFIG_FILE = "profiles.json";
const PROFILE_CONFIG_PRIVILEGED_LABEL = "{asid}";

class ProfileConfig extends BaseConfig {
  constructor() {
    super();
    this.profileList = null;
    this.ucProfileList = null;
    this.privilegedUserPermissionMap = null;
    this.validator = new Validator(Path.join(__dirname, this.VALIDATION_TYPES_RELATIVE_PATH));
  }

  getMergedProfiles() {
    if (!this.profileList) {
      this.loadProfilesConfig();
    }
    return this.mergedProfiles;
  }

  /**
   * return profiles
   * @returns {null|Array}
   */
  getProfiles() {
    if (!this.profileList) {
      this.loadProfilesConfig();
    }
    return this.profileList;
  }

  /**
   * return use case profiles
   * @param {String} ucName
   * @returns {Array}
   */
  getUseCaseProfiles(ucName) {
    if (this.ucProfileList[ucName]) {
      return this.ucProfileList[ucName];
    } else {
      return [];
    }
  }

  getUseCaseAwidProfiles(ucName) {
    if (this.ucAwidProfileList[ucName]) {
      return this.ucAwidProfileList[ucName];
    } else {
      return [];
    }
  }

  /**
   * check if call is privileged
   * @param {string} asid
   * @returns {boolean}
   */
  isPrivilegedCall(asid) {
    if (!this.privilegedUserPermissionMap) {
      this.loadProfilesConfig();
    }
    return this.privilegedUserPermissionMap.hasOwnProperty(asid);
  }

  /**
   * return array of privileged profiles for specific user
   * @param {Object} asid
   * @param {String} uuId
   * @returns {Array}
   */
  getPrivilegedUserProfiles(asid, uuId) {
    let privilegedProfiles = this.privilegedUserPermissionMap[asid];
    if (!privilegedProfiles) {
      return [];
    } else {
      let permissions = privilegedProfiles["permissionMap"];
      if (permissions[uuId]) {
        return permissions[uuId];
      } else {
        return [];
      }
    }
  }

  /**
   * return array of privileged profiles for specific useCase
   * @param  {Object} asid
   * @param {String} ucName
   * @returns {Array}
   */
  getPrivilegedUseCaseProfiles(asid, ucName) {
    let ucs = this.privilegedUserPermissionMap[asid]["useCaseMap"];
    if (ucs[ucName]) {
      return ucs[ucName];
    } else {
      return [];
    }
  }

  /**
   * load mapped structure of profiles.json
   */
  loadProfilesConfig() {
    // app profiles
    let applicationConfig = this.getAppConfig(PROFILES_CONFIG_FILE);
    // workspace profiles
    let workspaceConfig = this.getAppWorkspaceConfig(PROFILES_CONFIG_FILE);
    // library profiles
    let libraryConfigs = this.getLibraryConfigs(PROFILES_CONFIG_FILE);

    let profilesConfig = [applicationConfig, workspaceConfig, ...libraryConfigs];

    // validate
    profilesConfig.forEach(config => this._validateProfilesConfig(config));
    // merge
    profilesConfig = mergeProfiles(profilesConfig);
    this.mergedProfiles = Object.assign({}, profilesConfig);

    this._mapPrivilegedUserPermission(profilesConfig);

    this.profileList = profilesConfig["*"]["profileList"];
    this.ucProfileList = profilesConfig["*"]["useCaseMap"];
    this.ucAwidProfileList = profilesConfig["*"]["privilegedUseCaseMap"];
  }

  _validateProfilesConfig(profilesConfig) {
    let validationResult = this.validator.validate("profilesType", profilesConfig);
    if (!validationResult.isValid()) {
      let invalidAttributes = validationResult.getMissingKeys();
      invalidAttributes.push(...validationResult.getInvalidValueKeys());
      invalidAttributes.push(...validationResult.getInvalidTypeKeys());
      let rootPosition = invalidAttributes.indexOf("$");
      invalidAttributes.splice(rootPosition, 1);
      throw new InvalidKeyError(PROFILES_CONFIG_FILE, invalidAttributes);
    }
  }

  /**
   * create mapping structure of profiles from profiles.json
   * @param {object} profileConfig
   * @private
   */
  _mapPrivilegedUserPermission(profileConfig) {
    //TODO check for invalid config attributes
    let asid = Config.get("asid");
    let privilegedUserMap = Config.get("privilegedUserMap");
    if (!asid || !privilegedUserMap) {
      return;
    }

    profileConfig[asid] = profileConfig[PROFILE_CONFIG_PRIVILEGED_LABEL];
    delete profileConfig[PROFILE_CONFIG_PRIVILEGED_LABEL];

    let permKeys = Object.keys(profileConfig[asid].permissionMap);
    permKeys.forEach(pKey => {
      if (pKey[0] === "{" && pKey[pKey.length - 1] === "}") {
        let updatedKey = pKey.substring(1, pKey.length - 1);
        profileConfig[asid].permissionMap[updatedKey] = profileConfig[asid].permissionMap[pKey];
        delete profileConfig[asid].permissionMap[pKey];
      }
    });

    let allowed = Object.keys(privilegedUserMap);
    let raw = profileConfig[asid]["permissionMap"];

    for (let i = 0; i < allowed.length; i += 1) {
      let allowName = allowed[i];

      const permission = Object.keys(raw)
        .filter(key => allowName === key)
        .reduce((obj, key) => {
          obj["uuIdentity"] = privilegedUserMap[key];
          obj[key] = raw[key];
          return obj;
        }, {});

      if (permission && Object.keys(permission).length !== 0 && permission.constructor === Object) {
        profileConfig[asid]["permissionMap"][permission.uuIdentity] = profileConfig[asid]["permissionMap"][allowName];
        delete profileConfig[asid]["permissionMap"][allowName];
      }
    }

    this.privilegedUserPermissionMap = {};
    this.privilegedUserPermissionMap[asid] = profileConfig[asid];
  }

  get PROFILES_CONFIG_FILE() {
    return PROFILES_CONFIG_FILE;
  }

  get PROFILE_CONFIG_PRIVILEGED_LABEL() {
    return PROFILE_CONFIG_PRIVILEGED_LABEL;
  }
}

module.exports = new ProfileConfig();
