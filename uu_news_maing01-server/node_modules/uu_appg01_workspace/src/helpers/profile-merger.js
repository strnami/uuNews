"use strict";

const { ProfilesMergeDuplicateKeyError } = require("../errors/startup-errors.js");

const PRIVILEGED_WORKSPACE = "{tid}-{asid}";
const PRIVILEGED_ASID = "{asid}";
const NON_PRIVILEGED = "*";
const CONFLICTS = "_@@conflicts";

class ProfileMerger {
  static mergeProfiles(profileConfigList) {
    let privilegedProfileLists = [];
    let privilegedPermissionMaps = [];
    let privilegedUseCaseMaps = [];
    let profileLists = [];
    let useCaseMaps = [];
    let privilegeAwidUseCaseMaps = [];

    for (const config of profileConfigList) {
      let privilegedConfig = config[PRIVILEGED_WORKSPACE] ? config[PRIVILEGED_WORKSPACE] : config[PRIVILEGED_ASID];
      privilegedProfileLists.push(privilegedConfig.profileList);
      privilegedPermissionMaps.push(privilegedConfig.permissionMap);
      privilegedUseCaseMaps.push(privilegedConfig.useCaseMap);
      profileLists.push(config[NON_PRIVILEGED].profileList);
      useCaseMaps.push(config[NON_PRIVILEGED].useCaseMap);
      privilegeAwidUseCaseMaps.push(config[NON_PRIVILEGED].privilegedUseCaseMap);
    }

    return {
      [PRIVILEGED_ASID]: {
        profileList: ProfileMerger._mergeListOfArrays(privilegedProfileLists),
        permissionMap: ProfileMerger._mergeListOfObjects(privilegedPermissionMaps),
        useCaseMap: ProfileMerger._mergeListOfObjects(privilegedUseCaseMaps)
      },
      [NON_PRIVILEGED]: {
        profileList: ProfileMerger._mergeListOfArrays(profileLists),
        useCaseMap: ProfileMerger._mergeListOfObjects(useCaseMaps),
        privilegedUseCaseMap: ProfileMerger._mergeListOfObjects(privilegeAwidUseCaseMaps)
      }
    };
  }

  static _mergeListOfArrays(list) {
    let flat = [].concat.apply([], list);
    return [...new Set(flat)];
  }

  static _mergeListOfObjects([app, ...libs]) {
    let merged = libs.reduce(this._mergeObjects, { [CONFLICTS]: new Set() });
    this._throwOnConflict(app, merged[CONFLICTS]);
    delete merged[CONFLICTS];
    return Object.assign(merged, app);
  }

  static _mergeObjects(merged, next) {
    for (const k in next) {
      if (k in merged) {
        if (JSON.stringify(next[k]) !== JSON.stringify(merged[k])) {
          // not conflict if same value (workaround for {asidOwner} definition)
          merged[CONFLICTS].add(k);
        }
      } else {
        merged[k] = next[k];
      }
    }
    return merged;
  }

  static _throwOnConflict(app, conflicts) {
    let unresolvedConflicts = [];
    conflicts.forEach(c => {
      if (!(c in app)) unresolvedConflicts.push(c);
    });
    if (unresolvedConflicts.length) {
      throw new ProfilesMergeDuplicateKeyError(unresolvedConflicts.join(", "));
    }
  }
}

module.exports = ProfileMerger;
