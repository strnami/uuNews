"use strict";

const { Config, OptsReader } = require("uu_appg01_core-utils");
const { AuthorizationService, AuthorizationError } = require("uu_appg01_core-authorization");
const WorkspaceAuthorizationResult = require("./workspace-authorization-result.js");
const ProfileConfig = require("./helpers/profile-config.js");
const SysAppWorkspaceModel = require("./models/sys-app-workspace-model.js");
const SysPermissionModel = require("./models/sys-permission-model.js");
const SysProfileModel = require("./models/sys-profile-model.js");
const RoleCastService = require("./helpers/role-cast-service.js");
const UuOs8UriHelper = require("./helpers/uu-os8-uri-helper.js");
const { UriBuilder } = require("uu_appg01_core-uri");
const { AppClient, ApplicationError } = require("uu_appg01_core-appclient");
const { LoggerFactory } = require("uu_appg01_core-logging");

const logger = LoggerFactory.get("WorkspaceAuthorizationService");

const PARAM_ROLE_MANAGEMENT_BASE_URI = "uu_app_workspace_role_management_uri";
const PARAM_ROLE_CAST_CACHE_TTL = "uu_app_workspace_role_cast_cache_ttl";

const DEFAULT_SERVICE_NAME = "uu_appg01_workspace";
const DEFAULT_ROLE_MANAGEMENT_BASE_URI = "https://api.plus4u.net";
const DEFAULT_ROLE_CAST_CACHE_TTL = 5 * 60 * 1000;
const DEFAULT_AUTHZ_STRATEGY = "roleGroupInterface";

const GGALL = "urn:uu:GGALL";
const GGPLUS4U = "urn:uu:GGPLUS4U";
const ANONYMOUS_USER = "0-0";
const PRIVILEGED = "privileged";

const Errors = require("./errors/authorization-errors");

class WorkspaceAuthorizationService {
  /**
   * Checks whether identity represented by the session is authorized to access resources at given uri. In case identity
   * is not authorized, error is not directly raised, but unauthorized authorization context is returned as result.
   * Logic which is performing authorization is then responsible to raise AccessDenied error in case there is no
   * alternative flow to handle unauthorized access.
   * @param {Session} session Instance of session representing authenticated user
   * @param {URI} uri Address of the use case
   * @returns {Promise<AuthorizationResult>} Authorization result
   */
  static async authorize(session, uri) {
    return await AuthorizationService.get(DEFAULT_SERVICE_NAME).authorize(session, uri);
  }

  /**
   * Creates new instance of uuAppWorkspace authorization service and registers it
   * as authorization service with given name.
   * @param {String} name Service name
   * @param {Object|null} options Service options
   */
  static create(name, options = {}) {
    let authService = new WorkspaceAuthorizationService(options);
    AuthorizationService._register(name, authService);
  }

  /**
   * Creates new instance of uuAppWorkspace authorization service.
   * @param options Service options
   * @private
   */
  constructor(options = {}) {
    let opts = new OptsReader(options, Config);
    let uu0S8CastServiceBaseUrl = opts.get(PARAM_ROLE_MANAGEMENT_BASE_URI, DEFAULT_ROLE_MANAGEMENT_BASE_URI);
    let castCacheTtl = opts.get(PARAM_ROLE_CAST_CACHE_TTL, DEFAULT_ROLE_CAST_CACHE_TTL);
    this._castService = new RoleCastService(uu0S8CastServiceBaseUrl, castCacheTtl);
    ProfileConfig.loadProfilesConfig();
  }

  async authorize(session, uri) {
    let identity = session.getIdentity();
    let uuId = (identity ? identity.getUuIdentity() : ANONYMOUS_USER) || ANONYMOUS_USER;

    let ucName = uri.getUseCase();
    let ucProfiles = ProfileConfig.getUseCaseProfiles(ucName);
    if (this._isPublicOnly(ucProfiles)) {
      return new WorkspaceAuthorizationResult({ uuIdentity: uuId, isAuthorized: true });
    }

    let ucAwidProfiles = [];
    let awidRuntimeMode;
    let awid = uri.getAwid();
    let privileged = ProfileConfig.isPrivilegedCall(awid);
    let privilegedUcProfiles = [];
    if (privileged) {
      privilegedUcProfiles = ProfileConfig.getPrivilegedUseCaseProfiles(awid, ucName);
    } else {
      try {
        awidRuntimeMode = await SysAppWorkspaceModel.getAwidRuntimeMode(awid);
      } catch (e) {
        awidRuntimeMode = null;
      }
      if (awidRuntimeMode && awidRuntimeMode.mode === PRIVILEGED) {
        ucAwidProfiles = ProfileConfig.getUseCaseAwidProfiles(ucName);
      }
    }

    if (ucProfiles.length === 0 && privilegedUcProfiles.length === 0 && ucAwidProfiles.length === 0) {
      return new WorkspaceAuthorizationResult({ uuIdentity: uuId, isAuthorized: false });
    } else if (privileged) {
      return this._authorizePrivileged(session, awid, privilegedUcProfiles);
    } else if (awidRuntimeMode && awidRuntimeMode.mode === PRIVILEGED) {
      return await this._authorizeUser(session, awid, ucAwidProfiles);
    } else {
      let awid = uri.getAwid();
      return await this._authorizeUser(session, awid, ucProfiles, uri.getUseCase());
    }
  }

  _isPublicOnly(ucProfiles) {
    if (ucProfiles.length === 1 && ucProfiles.indexOf("Public") > -1) {
      return true;
    } else {
      return false;
    }
  }

  _authorizePrivileged(session, awid, ucProfiles, uuAppErrorMap = {}) {
    let identity = session.getIdentity();
    let uuId = (identity ? identity.getUuIdentity() : ANONYMOUS_USER) || ANONYMOUS_USER;

    let authorizedProfiles = [];
    let profileList = ProfileConfig.getPrivilegedUserProfiles(awid, uuId);

    ucProfiles.forEach(function(element) {
      if (profileList.includes(element)) {
        authorizedProfiles.push(element);
      }
    });

    let contextData = {
      uuIdentity: uuId,
      authorizedProfiles: authorizedProfiles,
      identityProfiles: profileList
    };
    return new WorkspaceAuthorizationResult(contextData);
  }

  async _authorizeUser(session, ...params) {
    let awid;
    let ucProfiles;
    let uuAppErrorMap;
    let useCaseName = null;
    let authorizationType;
    let uri;

    if (typeof params[0] === "string") {
      awid = params[0];
      ucProfiles = params[1];
      useCaseName = params[2];
      uuAppErrorMap = params[3] || {};
    } else {
      uri = params[0];
      authorizationType = params[1];
      uuAppErrorMap = params[2] || {};
      awid = uri.awid;
      useCaseName = uri.useCase;
      ucProfiles = ProfileConfig.getUseCaseProfiles(useCaseName);
    }

    let identity = session.getIdentity();
    let uuId = (identity ? identity.getUuIdentity() : ANONYMOUS_USER) || ANONYMOUS_USER;

    // SYS OWNER AUTHORIZATION
    let appWorkspace = await SysAppWorkspaceModel.get(awid);
    if (!Array.isArray(ucProfiles)) {
      ucProfiles = [ucProfiles];
    }

    let allProfiles = appWorkspace["profileList"];
    let profileList = [];

    if (appWorkspace["awidOwner"] === uuId) {
      profileList.push("AwidOwner");
    }

    // PERMISSION AUTHORIZATION
    let permissionProfiles;
    try {
      permissionProfiles = await SysPermissionModel.getProfileCodesForUser(awid, uuId);
    } catch (e) {
      throw new AuthorizationError(`Unable to get profile codes for user ${uuId}`, e);
    }

    if (permissionProfiles && permissionProfiles.length > 0) {
      profileList = profileList.concat(permissionProfiles[0]["profileList"]);
    }

    // SPECIALIZED AUTHORIZATION
    if (!authorizationType) {
      authorizationType = appWorkspace["authorizationStrategy"] || DEFAULT_AUTHZ_STRATEGY;
    }

    switch (authorizationType) {
      case "roleGroupInterface":
        let uncheckedProfiles = allProfiles.filter(x => profileList.indexOf(x.code) < 0);

        let storedProfiles;
        try {
          storedProfiles = await SysProfileModel.getProfiles(awid, uncheckedProfiles);
        } catch (e) {
          throw new AuthorizationError(`Unable to get profiles ${uncheckedProfiles}`, e);
        }

        let castRegistry = new Map();
        for (let i = 0; i < storedProfiles["itemList"].length; i += 1) {
          let profile = storedProfiles["itemList"][i];
          let profileCode = profile["code"];
          let roleUri = profile["roleUri"];

          if (!roleUri) {
            continue;
          }

          if (roleUri === GGALL) {
            profileList.push(profileCode);
            continue;
          }

          if (roleUri === GGPLUS4U && uuId !== ANONYMOUS_USER) {
            profileList.push(profileCode);
            continue;
          }

          this._fillCastRegistry(castRegistry, roleUri, profileCode);
        }

        // cast verification
        if (uuId !== ANONYMOUS_USER && castRegistry.size > 0) {
          let allSubjectUris = Array.from(castRegistry.keys());
          let verifyCastResult = [];

          let result = await this._castService.verifyCastExistence(session, allSubjectUris);

          if (result) {
            verifyCastResult = verifyCastResult.concat(result);
          }

          verifyCastResult.forEach(verifyCastEntry => {
            if (verifyCastEntry) {
              for (let [roleUri, profileCodes] of castRegistry) {
                if ((verifyCastEntry.uuOS9 && verifyCastEntry.role === roleUri) ||
                  (!verifyCastEntry.uuOS9 && UuOs8UriHelper.equalUris(verifyCastEntry.role, roleUri))) {
                  profileList = profileList.concat(profileCodes);
                }
              }
            }
          });
        }

        break;
      case "artifact":
        if (appWorkspace["artifactUri"]) {
          let uriBuilder = UriBuilder.parse(appWorkspace["artifactUri"]);
          uriBuilder.setUseCase("uuArtifactIfc/authorizeMe");

          const code = uriBuilder._parameters["code"];
          const id = uriBuilder._parameters["id"];

          let parameters = {
            useCase: useCaseName,
            type: "full"
          };

          if (id) {
            parameters.id = id;
          }
          if (code) {
            parameters.code = code;
          }

          uriBuilder.clearParameters();
          const artifactAuthorizeUri = uriBuilder.toString();

          let headers = {};
          headers["Authorization"] = await session.getCallToken(artifactAuthorizeUri);
          try {
            let result = await AppClient.get(artifactAuthorizeUri, parameters, { headers });
            profileList = profileList.concat(result.data["userUuAppProfileList"]);
          } catch (e) {
            if (e instanceof ApplicationError) {
              logger.info("User is not authorized by artifact authorization.", e);
            } else {
              if (profileList.filter(x => ucProfiles.indexOf(x) !== -1) && ucProfiles.indexOf("Public") === -1) {
                throw new Errors.AuthorizationFailed({ uuAppErrorMap }, e);
              } else {
                logger.error(`Remote call in artifact authorization failed, cause: ${e}`);
              }
            }
          }
        } else {
          logger.info("Artifact authorization: Trying to use artifact authorization when artifactUri is not set.");
        }

        break;
      case "boundArtifact":
        //TODO: boundArtifact authorization strategy
        break;
    }

    // AUTHORIZATION EVALUATION
    profileList = [...new Set(profileList)]; // unique profiles
    let authorizedProfiles = new Set([...profileList].filter(x => ucProfiles.includes(x))); // intersection

    let contextData = {
      uuIdentity: uuId,
      authorizedProfiles: Array.from(authorizedProfiles),
      identityProfiles: profileList
    };
    if (ucProfiles.includes("Public")) {
      contextData.isAuthorized = true;
    }
    return new WorkspaceAuthorizationResult(contextData);
  }

  _fillCastRegistry(castRegistry, roleUri, profileCode) {
    if (castRegistry.has(roleUri)) {
      castRegistry.get(roleUri).push(profileCode);
    } else {
      castRegistry.set(roleUri, [profileCode]);
    }
  }
}

// Register default uuAppWorkspace authorization service
WorkspaceAuthorizationService.create(DEFAULT_SERVICE_NAME);

module.exports = WorkspaceAuthorizationService;
