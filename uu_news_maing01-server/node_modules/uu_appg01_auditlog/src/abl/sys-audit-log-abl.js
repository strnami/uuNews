"use strict";

const { UseCaseContext, ValidationHelper } = require("uu_appg01_core-appserver");
const { Validator } = require("uu_appg01_core-validation");
const { DaoFactory, Lock, ObjectLocked } = require("uu_appg01_objectstore");
const { Config } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const LogStoreClient = require("../log-store-client");

const SysAuditLogRecordError = require("../api/errors/sys-auditlog-error.js");

const WARNINGS = {
  createAuditLogRecord: {
    unsupportedKeys: {
      code: `${SysAuditLogRecordError.CreateAuditLogRecord.UC_CODE}unsupportedKeys`
    }
  },
  listByTimeAndSpp: {
    unsupportedKeys: {
      code: `${SysAuditLogRecordError.ListByTimeAndSpp.UC_CODE}unsupportedKeys`
    }
  },
  listMyByTime: {
    unsupportedKeys: {
      code: `${SysAuditLogRecordError.ListMyByTime.UC_CODE}unsupportedKeys`
    }
  },
  deleteBeforeTime: {
    unsupportedKeys: {
      code: `${SysAuditLogRecordError.DeleteBeforeTime.UC_CODE}unsupportedKeys`
    }
  }
};
const DEFAULT_PAGE_INFO = {
  pageIndex: 0,
  pageSize: 1000
};

class SysAuditLogAbl {

  constructor() {
    this.logger = LoggerFactory.get("uuapp.auditlog.SysAuditLogAbl");
    this.validator = Validator.load();
    this.asid = Config.get("asid");
    this.dao = DaoFactory.getDao("sysAuditLogRecord");
    this.configDao = DaoFactory.getDao("sysAuditLogConfig");
    this.recordsWritten = 0;
    this.maxRecordCount = Config.get("uu_app_auditlog_max_record_count");
    if (this.maxRecordCount == null) {
      this.maxRecordCount = Config.get("uu_app_auditlog_record_count_limit");
    }
    this.recordLimitCheckAfter = Config.get("uu_app_auditlog_record_limit_check_after");
    this.recordPruneEnabled = this.maxRecordCount != null && this.maxRecordCount > 0 &&
      this.recordLimitCheckAfter != null && this.recordLimitCheckAfter > 0;
    if (this.recordPruneEnabled) {
      this.minRecordCount = Config.get("uu_app_auditlog_min_record_count");
      if (this.minRecordCount == null || this.minRecordCount < 0 || this.minRecordCount > this.maxRecordCount) {
        this.minRecordCount = this.maxRecordCount;
      }
    } else {
      this.logger.warn(
        "UU.APP.AUDITLOG/CONFIG_EXPECTED: The uuAuditLog storage retency is not configured (maxRecordCount, minRecordCount, recordLimitCheckAfter), beware of database overflow! See documentation for details.");
    }

    this.appLogStoreUri = Config.get("uu_app_auditlog_app_logstore_uri");
    this.appLogStoreTransferAfterCount = Config.get("uu_app_auditlog_app_logstore_transfer_after_count");
    if (!this.appLogStoreTransferAfterCount || this.appLogStoreTransferAfterCount < 0) {
      this.appLogStoreTransferAfterCount = 1000;
    }
    this.appLogStoreNotTransferedCount = 0;
  }

  async createAuditLogRecord(dtoIn) {
    //HDS 1
    //HDS 1.1
    let validationResult = this.validator.validate("createDtoInSchemaType", dtoIn);
    //HDS 1.2, A1
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.createAuditLogRecord.unsupportedKeys.code,
      SysAuditLogRecordError.CreateAuditLogRecord.InvalidDtoIn
    );

    let uri = UseCaseContext.getUri();
    let awid = uri.getAwid();
    let customSession = UseCaseContext.getSession();
    let requestId = UseCaseContext.getRequestId();
    let date = new Date();

    // HDS 2
    let auditLogRecord = {
      awid: awid,
      spp: uri.getSpp() || "",
      useCase: uri.getUseCase(),
      requestId: requestId,
      sid: customSession.getAuthenticationId(),
      logTime: date,
      severity: dtoIn.severity,
      eventTypeCode: dtoIn.eventTypeCode,
      message: dtoIn.message,
      parameters: dtoIn.parameters
    };
    const identity = customSession.getIdentity();
    if (identity) {
      auditLogRecord.identity = identity.getUuIdentity();
      auditLogRecord.identityName = identity.getName();
      auditLogRecord.identityType = identity.getType();
    }

    // HDS 3
    let dtoOut = await this.dao.create(auditLogRecord);

    // HDS 4 - import logRecords to the uuAppLogStore
    if (this.appLogStoreUri) {
      // hds 4.2.1
      this.appLogStoreNotTransferedCount++;
      if (this.appLogStoreNotTransferedCount >= this.appLogStoreTransferAfterCount) {
        this.appLogStoreNotTransferedCount = 0;
        this.logger.info(`Transferring AuditLog Records to uuAppLogStore ${this.appLogStoreUri}.`);
        try {
          // hds 4.2.2 - hds 4.2.5
          await this._transferLogsToLogStore(this.appLogStoreUri);
          this.logger.info("Transferring AuditLog Records finished without error.");
        } catch (e) {
          this.logger.error(`Failed to transfer AuditLog Records to uuAppLogStore ${this.appLogStoreUri}`, e);
        }
      }
    }

    // HDS 5
    {
      if (this.recordPruneEnabled) {
        this.recordsWritten += 1;
        if (this.recordsWritten >= this.recordLimitCheckAfter) {
          this.recordsWritten = 0;
          this.logger.debug("Checking number of uuAuditLog records.");
          try {
            if (await this.dao.prune(this.minRecordCount, this.maxRecordCount)) {
              this.logger.info("Pruning of old uuAuditLog records triggered.");
            }
          } catch (e) {
            this.logger.error("Pruning of old uuAuditLog records failed.", e);
          }
        }
      }
    }

    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  async _transferLogsToLogStore(logStoreUri) {
    // find and lock the oldest non-transferred log
    let asidAuditLogConfig;
    let lock = new Lock("logStoreTransfer", 300);
    try { // hds 4.2.1
      asidAuditLogConfig = await this.configDao.lockByAwid(this.asid, lock);
    } catch (e) {
      if (e instanceof ObjectLocked) {
        this.logger.warn("Transfer is already in progress");
        return;
      }
      throw e;
    }

    let latestTransferredLogId = asidAuditLogConfig.latestTransferredLogId;

    try {
      let pageInfo = {
        pageSize: 1000,
        pageIndex: 0
      };

      let iteration = 0;
      while (true) {
        // hds 4.2.2
        const logsToTransfer = await this.dao.listLogsToTransfer(latestTransferredLogId, pageInfo);
        if (iteration++ % 50 == 0) {
          this.logger.info("Remaining logs to transfer: " + logsToTransfer.pageInfo.total);
        }

        if (logsToTransfer.itemList.length == 0) {
          this.logger.debug(`Nothing to transfer.`);
          break;
        }

        // hds 4.2.3
        const res = await LogStoreClient.importLogRecords(logStoreUri, logsToTransfer.itemList);
        this.logger.debug(`LogRecords transferred successfully. Count ${res.logRecordCount}`);

        // hds 4.2.4
        latestTransferredLogId = logsToTransfer.itemList.slice(-1)[0].id;
        await this.extendLock(lock);
        await this.configDao.updateById(asidAuditLogConfig.id, { latestTransferredLogId }, lock);

        // hds 4.2.5
        if (logsToTransfer.itemList.length < pageInfo.pageSize) {
          break;
        }
      }
    } finally {
      // hds 4.2.6
      await this.configDao.unlockById(asidAuditLogConfig.id, lock);
    }
  }

  // extend lock if its duration is less than 1 minute
  async extendLock(lock) {
    const t = new Date();
    t.setSeconds(t.getSeconds() + 60);

    if (lock.expiration < t) {
      await lock.extendExpiration(300);
    }
  }

  async listAuditLogRecordsByTimeAndSpp(awid, dtoIn) {
    //HDS 1
    //HDS 1.1
    let validationResult = this.validator.validate("listByTimeAndSppDtoInSchemaType", dtoIn);
    //HDS 1.2, A1
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.listByTimeAndSpp.unsupportedKeys.code,
      SysAuditLogRecordError.ListByTimeAndSpp.InvalidDtoIn
    );

    // HDS 1.3
    if (dtoIn.timeFrom >= dtoIn.timeTo) {
      // A2
      throw new SysAuditLogRecordError.ListByTimeAndSpp.InvalidIntervalDefinition(
        { uuAppErrorMap },
        { timeFrom: dtoIn.timeFrom, timeTo: dtoIn.timeTo }
      );
    }

    // HDS 1.4
    if (dtoIn.timeFrom) {
      dtoIn.timeFrom = new Date(dtoIn.timeFrom);
    }
    if (dtoIn.timeTo) {
      dtoIn.timeTo = new Date(dtoIn.timeTo);
    }
    let pageInfo = Object.assign(DEFAULT_PAGE_INFO, dtoIn.pageInfo);

    // HDS 2.1 2.2 2.3 realized in DAO method

    // HDS 3
    let logRecordList = await this.dao.listByTimeAndSpp(awid, dtoIn.timeFrom, dtoIn.timeTo, dtoIn.spp, pageInfo);

    let dtoOut = {};

    // HDS 4
    dtoOut.logRecordList = logRecordList["itemList"];

    // HDS 5
    dtoOut.pageInfo = logRecordList["pageInfo"];
    dtoOut.uuAppErrorMap = uuAppErrorMap;

    // HDS 6
    return dtoOut;
  }

  async listMyAuditLogRecordsByTime(awid, session, dtoIn) {
    //HDS 1
    //HDS 1.1
    let validationResult = this.validator.validate("listMyByTimeDtoInSchemaType", dtoIn);

    //HDS 1.2, A1
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.listMyByTime.unsupportedKeys.code,
      SysAuditLogRecordError.ListMyByTime.InvalidDtoIn
    );

    // HDS 1.3
    if (dtoIn.timeFrom >= dtoIn.timeTo) {
      // A2
      throw new SysAuditLogRecordError.ListMyByTime.InvalidIntervalDefinition(
        { uuAppErrorMap },
        { timeFrom: dtoIn.timeFrom, timeTo: dtoIn.timeTo }
      );
    }

    // HDS 1.4
    if (dtoIn.timeFrom) {
      dtoIn.timeFrom = new Date(dtoIn.timeFrom);
    }
    if (dtoIn.timeTo) {
      dtoIn.timeTo = new Date(dtoIn.timeTo);
    }
    let pageInfo = Object.assign(DEFAULT_PAGE_INFO, dtoIn.pageInfo);

    // HDS 2.1 2.2 realized in DAO method

    // HDS 3
    let identity = session.getIdentity().getUuIdentity();

    // HDS 4
    let logRecordList = await this.dao.listByTimeAndIdentity(awid, dtoIn.timeFrom, dtoIn.timeTo, identity, pageInfo);

    let dtoOut = {};

    // HDS 5
    dtoOut.logRecordList = logRecordList["itemList"];

    // HDS 6
    dtoOut.pageInfo = logRecordList["pageInfo"];
    dtoOut.uuAppErrorMap = uuAppErrorMap;

    // HDS 7
    return dtoOut;
  }

  async deleteAuditLogRecordsBeforeTime(awid, dtoIn) {
    //HDS 1
    //HDS 1.1
    let validationResult = this.validator.validate("deleteBeforeTimeDtoInSchemaType", dtoIn);

    //HDS 1.2, A1
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.deleteBeforeTime.unsupportedKeys.code,
      SysAuditLogRecordError.DeleteBeforeTime.InvalidDtoIn
    );

    // HDS 2
    const toTime = new Date(dtoIn.toTime);

    let deleteCounter = await this.dao.count({
      // TODO, replace this with result of deleteMany operation (after uuAppObjectStore gets fixed)
      awid,
      $or: [
        {
          logTime: { $lte: toTime }
        },
        {
          logTime: { $lte: toTime.toISOString() }
        }
      ]
    });

    await this.dao.deleteBeforeTime(awid, toTime);

    let dtoOut = {};

    // HDS 3
    dtoOut.deletedCount = deleteCounter;
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    // HDS 4
    return dtoOut;
  }

}

module
  .exports = new SysAuditLogAbl();
