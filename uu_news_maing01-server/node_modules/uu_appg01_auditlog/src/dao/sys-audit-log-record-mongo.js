"use strict";

const { UuObjectDao } = require("uu_appg01_objectstore");
const { DbConnection } = require("uu_appg01_datastore");

class SysAuditLogRecordMongo extends UuObjectDao {
  async createSchema() {
    await super.createIndex({ awid: 1, _id: 1 }, { unique: true });
    await super.createIndex({ awid: 1, logTime: -1, spp: 1 });
    await super.createIndex({ awid: 1, logTime: -1, identity: 1 });
  }

  async create(uuObject) {
    return await super.insertOne(uuObject);
  }

  async listByTimeAndSpp(awid, timeFrom, timeTo, spp, pageInfo = {}) {
    let filter = this.buildAwidLogTimeQuery(awid, timeFrom, timeTo);

    if (typeof spp === "string" || spp instanceof String) {
      filter.spp = spp;
    }

    return await super.find(filter, pageInfo, { logTime: -1 }, { sys: 0 });
  }

  async listByTimeAndIdentity(awid, timeFrom, timeTo, identity, pageInfo) {
    let filter = this.buildAwidLogTimeQuery(awid, timeFrom, timeTo);

    if (identity) {
      filter.identity = identity;
    }

    return await super.find(filter, pageInfo, { logTime: -1 }, { sys: 0 });
  }

  async deleteBeforeTime(awid, toTime) {
    let filter = {
      awid,
      $or: [
        {
          logTime: { $lte: toTime }
        },
        {
          logTime: { $lte: toTime.toISOString() }
        }
      ]
    };

    return await super.deleteMany(filter);
  }

  async getCount() {
    return await super.count({});
  }

  async prune(minCount, maxCount) {
    let db = await DbConnection.get(this.customUri);
    let collection = await db.collection(this.collectionName);
    let recordCount = await collection.count();
    if (recordCount < maxCount) {
      return false;
    }
    let sort = { _id: -1 };
    let cursor = await collection.find().sort(sort).limit(minCount).skip(minCount - 1);
    let lastRecord = null;
    if ((await cursor.hasNext()) && (lastRecord = await cursor.next())) {
      await collection.remove({ _id: { $lte: lastRecord._id } }, { w: 0 });
      return true;
    } else {
      // We were over limit, but no barrier record was returned - no problem, there was
      // probably another pruning initiated from another node
      return false;
    }
  }

  async listLogsToTransfer(latestTransferredLogId, pageInfo) {
    const filter = latestTransferredLogId ? { _id: { $gt: latestTransferredLogId } } : {};
    return await super.find(filter, pageInfo, { _id: 1 });
  }

  buildAwidLogTimeQuery(awid, timeFrom, timeTo) {
    let filter = { awid };

    if (timeFrom || timeTo) {
      filter["$and"] = [];
    }

    if (timeFrom) {
      filter["$and"].push({
        $or: [
          {
            // for backward compatibility -> logTime was stored as a String in uuAppAuditLog v1.0.x
            logTime: { $gte: timeFrom }
          },
          {
            logTime: { $gte: timeFrom.toISOString() }
          }
        ]
      });
    }

    if (timeTo) {
      filter["$and"].push({
        $or: [
          {
            logTime: { $lte: timeTo }
          },
          {
            logTime: { $lte: timeTo.toISOString() }
          }
        ]
      });
    }

    return filter;
  }
}

module.exports = SysAuditLogRecordMongo;
