"use strict";

const Fs = require("fs");
const { Socket } = require("net");
const { MongoClient } = require("mongodb");

const { TestServer } = require("uu_appg01_core-test");
const { TestMongo } = require("uu_appg01_datastore-test");

const { BaseError, Config } = require("uu_appg01_server").Utils;
const { UriBuilder } = require("uu_appg01_server").Uri;
const { AuthenticationService } = require("uu_appg01_server").Authentication;
const { AppClient } = require("uu_appg01_server");

try {
  // Ensure initialization of oidc library if available
  require("uu_appg01_oidc").AuthenticationService;
  Config.set(AuthenticationService.DEFAULT_PROVIDER_PARAM, "uu_appg01_oidc");
} catch (e) {
  console.warn("Library uu_appg01_oidc is not installed, ensure other realization of AuthenticationService is available.", e);
}

/**
 * Helper component for implementation of application tests.
 */
class TestHelper {
  /**
   * Creates new isntance of TestHelper.
   * @private
   */
  constructor() {
    this._tid = null;
    this._asid = null;
    this._awid = null;
    this._userMap = {};
    this._userList = null;
    this._runtimeMode = null;
    this._awidOwner = null;
    this._licenseOwner = null;
    this._sessions = {};
    this._activeSession = null;
    this._testServer = null;
    this._gatewayUrl = null;
    this._testMongo = null;
  }

  /**
   * Returns port of running server.
   * @returns {Number} Port of running server
   */
  getPort() {
    return this._testServer ? this._testServer.getPort() : null;
  }

  /**
   * Returns gateway URL of running server.
   * @returns {String} Gateway URL of running server
   */
  getGatewayUrl() {
    return this._testServer ? this._testServer.getGatewayUrl() : null;
  }

  /**
   * Returns TID of running server.
   * @returns {String} TID of running server
   */
  getTid() {
    return this._tid;
  }

  /**
   * Returns ASID of running server.
   * @returns {String} ASID of running server
   */
  getAsid() {
    return this._asid;
  }

  /**
   * Returns default AWID of running server.
   * @returns {String} Default AWID of running server
   */
  getAwid() {
    return this._awid;
  }

  /**
   * Initializes test environment (starts embedded application and database server).
   * @param {String} appPath Path to application configuration file (defaults to "<%cwd%>/app.js")
   * @param {Object} options Additional test options
   * @param {String} options.setupDbScript Path to mongo shell script file or script content to be executed on setup
   * @param {boolean} options.authEnabled Allows disabling of authentication and authorization (defaults to true)
   * @param {boolean} options.verbose If set to false, server logs only error messages (defaults to false)
   * @param {String} options.mongoDbVersion Version of the mongoDB binary.
   */
  async setup(appPath = null, options = {}) {
    if (appPath != null && typeof appPath === "object") {
      options = appPath;
      appPath = null;
    }
    this._loadTestConfiguration();
    this._opts = options;
    if (this._opts.authEnabled == false) {
      Config.set("uu_app_authentication_unprotected_uri_regexp", ".*");
      Config.set("uu_app_authorization_unprotected_uri_regexp", ".*");
    }
    await this._startMongoDB();
    await this._startServer(appPath, this._opts.verbose);
    await this.executeDbScript(this._opts.setupDbScript);
  }

  /**
   * Allows initialization or modification of database by running given mongo shell script
   * (script is invoked in scope of primary storage, it is possible to switch database inside
   * script via "use <db>;" instruction).
   * @param {String} script Path to script file or script content
   * @returns {Promise<*>} Mongo result object
   */
  async executeDbScript(script) {
    let connectionString = Config.get("uuSubAppDataStoreMap").primary;
    if (!connectionString || !script) {
      return;
    }
    if (Fs.existsSync(script)) {
      script = Fs.readFileSync(file, "utf8");
    }

    let result = null;
    await this._mongoClientExec(connectionString, async client => {
      result = await client.db().eval(script);
    });
    return result;
  }

  /**
   * Drops all data from testing database.
   */
  async dropDatabase() {
    let dataStoreMap = Config.get("uuSubAppDataStoreMap") || {};

    let promises = [];
    Object.values(dataStoreMap).forEach(testDb => {
      promises.push(this._dropMongoDb(testDb));
    });

    await Promise.all(promises);
  }

  /**
   * Cleans test environment (stops embedded appplication and database server).
   */
  async teardown() {
    if (this._opts.authEnabled == false) {
      Config.delete("uu_app_authentication_unprotected_uri_regexp");
      Config.delete("uu_app_authorization_unprotected_uri_regexp");
    }
    await this._testServer.stop();
    this._testServer = null;
    if (this._testMongo) {
      await this._testMongo.stop();
      this._testMongo = null;
    }
  }

  /**
   * Executes POST HTTP request for logged user.
   * @param {String} useCase Use case name that will be used as the part of uri
   * @param {Object} dtoIn Hash containing request parameters
   * @param {Session} session Instance of session
   * @param {String} tid Territory id that will be used as the part of uri (workspace)
   * @param {String} awid Application workspace id that will be used as the part of uri (workspace)
   * @returns {Promise<*>} Response including dtoOut
   */
  async executePostCommand(useCase, dtoIn = {}, session = null, tid = null, awid = null) {
    if (typeof session === "string") {
      awid = tid;
      tid = awid;
      session = null;
    }
    let uri = new UriBuilder()
      .setGateway(this._gatewayUrl)
      .setProduct("vendor-app-subApp")
      .setAwid(awid || this._awid)
      .setUseCase(useCase)
      .toUri();
    return await AppClient.post(uri, dtoIn, { session: session || this._activeSession });
  }

  /**
   * Executes GET HTTP request for logged user.
   * @param {String} useCase Use case name that will be used as the part of uri
   * @param {Object} dtoIn Hash containing request parameters
   * @param {Session} session Instance of session
   * @param {String} tid Territory id that will be used as the part of uri (workspace)
   * @param {String} awid Application workspace id that will be used as the part of uri (workspace)
   * @returns {Promise<*>} Response including dtoOut
   */
  async executeGetCommand(useCase, dtoIn = {}, session = null, tid = null, awid = null) {
    if (typeof session === "string") {
      awid = tid;
      tid = awid;
      session = null;
    }
    let uri = new UriBuilder()
      .setGateway(this._gatewayUrl)
      .setProduct("vendor-app-subApp")
      .setAwid(awid || this._awid)
      .setUseCase(useCase)
      .toUri();
    return await AppClient.get(uri, dtoIn, { session: session || this._activeSession });
  }

  /**
   * Initializes app workspace. All parameters are optional (if not passed, values from the application
   * configuration are used).
   * @param tid Territory ID
   * @param awid Application workspace ID
   * @param awidOwner UuIdentity of awidOwner
   * @param licenseOwner UuIdentity of app. licence owner
   * @returns {Promise<*>} Response including dtoOut
   */
  async initAppWorkspace(tid = null, awid = null, awidOwner = null, licenseOwner = null) {
    let dtoIn = {};
    dtoIn["awid"] = awid || this._awid;
    dtoIn["awidOwner"] = awidOwner || this._awidOwner;
    dtoIn["licenseOwner"] = licenseOwner || this._licenseOwner;
    dtoIn["userList"] = this._userList;
    dtoIn["runtimeMode"] = this._runtimeMode;
    let session = await this.login("AsidOwner", false, false);
    return await this.executePostCommand("sys/initAppWorkspace", dtoIn, session, tid || this._tid, this._asid);
  }

  /**
   * Initializes app and set runtime mode to standard by default.
   * @param mode (standard|privileged)
   * @param asid
   * @param to datetime
   * @returns {Promise<void>}
   */
  async initApp(mode = "standard", asid = this._asid, to = null) {
    let dtoIn = {};
    dtoIn["runtimeMode"] = { mode, to };
    let session = await this.login("AsidOwner", false, false);
    await this.executePostCommand("sys/initApp", dtoIn, session, this._tid, asid);
  }

  /**
   * Login user specified by name.
   * @param {String} userName Name of user for whom login will be processed
   * @param {boolean} createPermission Flag for creating permissions. If is set to true, then permission(s) will be
   *   created for given user.
   * @param {boolean} globalLogin Flag for save session. If is set to true, then session is saved (every next call of request will be authorized under this user).
   *   of request will be authorized under this user).
   * @returns {Promise<Session>} Instance of user session
   */
  async login(userName, createPermission = true, globalLogin = true) {
    if (this._opts.authEnabled == false) {
      return null;
    }
    if (createPermission) {
      await this.createPermission(userName);
    }
    let session = this._sessions[userName];
    if (!session) {
      let user = this._userMap[userName];
      if (!user) {
        throw new BaseError(`Login failed. User ${userName} not found`);
      }
      if (!user.accessCode1 || !user.accessCode2) {
        throw new BaseError(
          `Login failed. User ${userName} has no defined access code(s) for obtaining authorization token.`
        );
      }
      let credentials = { access_code1: user.accessCode1, access_code2: user.accessCode2 };
      session = await AuthenticationService.authenticate(credentials);
      this._sessions[userName] = session;
    }
    if (globalLogin) {
      this._activeSession = session;
    }
    return session;
  }

  /**
   * Create permission(s) for given user.
   * @param {String} userName Name of user for whom permissions will be created.
   */
  async createPermission(userName) {
    let user = this._userMap[userName];
    if (!user) {
      throw new BaseError(`Creating permission(s) failed. User ${userName} not found`);
    }
    if (!user.profileList) {
      throw new BaseError(`Creating permission(s) failed. User ${userName} has no defined profile list.`);
    }
    if (!user.uuIdentity) {
      throw new BaseError(`Creating permission(s) failed. User ${userName} has no defined uuIdentity.`);
    }
    let session = await this.login("AwidOwner", false, false);
    let promises = user.profileList.map(async permCode => {
      let parameters = {
        profileCode: permCode,
        uuIdentityList: user.uuIdentity
      };
      await this.executePostCommand("sys/createPermission", parameters, session);
    });
    await Promise.all(promises);
  }

  /**
   * Load test configuration and initializes variables.
   * @private
   */
  _loadTestConfiguration() {
    this._tid = Config.get("tid");
    this._asid = Config.get("asid");
    this._userMap = Config.get("userMap") || {};
    let sysAppWorkspace = Config.get("sysAppWorkspace") || {};
    this._awid = sysAppWorkspace.awid;
    this._awidOwner = sysAppWorkspace.awidOwner;
    this._licenseOwner = sysAppWorkspace.licenseOwner || {};
    this._userList = sysAppWorkspace.userList || [];
    this._runtimeMode = sysAppWorkspace.runtimeMode || { mode: "standard" };
  }

  /**
   * Starts embedded database server (Uses local database server if it is configured in test.json and running).
   * @private
   */
  async _startMongoDB() {
    let dataStoreMap = this._getDataStoreTestConfiguration();
    for (let dataStore in dataStoreMap) {
      if (await this._isMongoStarted(dataStoreMap[dataStore])) {
        await this._dropMongoDb(dataStoreMap[dataStore]);
      } else {
        dataStoreMap[dataStore] = (await this._getTestMongo()).getConnectionString(dataStore);
      }
    }
    if (Object.keys(dataStoreMap).length == 0) {
      let testMongo = await this._getTestMongo();
      dataStoreMap["primary"] = testMongo.getConnectionString("primary");
      dataStoreMap["binary"] = testMongo.getConnectionString("binary");
    }

    Config.set("uuSubAppDataStoreMap", dataStoreMap);

    // start embedded db for uuAppBinaryStoreg02 library
    let configObject = Config.toJSON();
    for (let key of Object.keys(configObject)) {
      const binaryStoreUriMatch = /^uu_app_binarystore_?(.*)_uri$/.exec(key);
      if (binaryStoreUriMatch) {
        const binaryStoreUri = configObject[key];
        // use embedded mongo only if uri is configured and empty or it is mongodb uri and the mongodb is not running
        if (binaryStoreUri === null || binaryStoreUri === "" || (binaryStoreUri.startsWith("mongodb") && !(await this._isMongoStarted(binaryStoreUri)))) {
          const dbName = binaryStoreUriMatch[1] || "binary";
          Config.set(key, (await this._getTestMongo()).getConnectionString(dbName));
        }
      }
    }
  }

  // returns original dataStoreMap from test.json (does not include embedded mongo uris)
  _getDataStoreTestConfiguration() {
    if (!this._testDataStoreMap) {
      this._testDataStoreMap = Config.get("uuSubAppDataStoreMap") || {};
    }
    return { ...this._testDataStoreMap };
  }

  async _dropMongoDb(connectionUri) {
    await this._mongoClientExec(connectionUri, async client => await client.db().dropDatabase());
  }

  async _mongoClientExec(connectionUri, operation) {
    let client = await MongoClient.connect(connectionUri, { useNewUrlParser: true, useUnifiedTopology: true });
    await operation(client);
    await client.close();
  }

  /**
   * Returns instance of the TestMongo. Starts a new one if it does not exist.
   * @return {Object} test MongoDb.
   * @private
   */
  async _getTestMongo() {
    if (!this._testMongo) {
      let options = {};
      if (this._opts.mongoDbVersion) {
        options.version = this._opts.mongoDbVersion;
      }
      if (this._opts.mongoDbStorageEngine) {
        options.storageEngine = this._opts.mongoDbStorageEngine;
      }
      if (this._opts.mongoDbReplSet) {
        options.replSet = this._opts.mongoDbReplSet;
      }
      this._testMongo = new TestMongo(options);
      await this._testMongo.start();
    }
    return this._testMongo;
  }

  /**
   * Starts embedded application server.
   * @param {String} appPath Path to application configuration file
   * @param {boolean} verbose Server verbosity
   * @private
   */
  async _startServer(appPath, verbose) {
    this._testServer = new TestServer(appPath, { verbose });
    await this._testServer.start();
    this._gatewayUrl = this._testServer.getGatewayUrl();
  }

  /**
   * Getter for backward compatibility.
   * @private
   */
  get tid() {
    return this.getTid();
  }

  /**
   * Getter for backward compatibility.
   * @private
   */
  get asid() {
    return this.getAsid();
  }

  /**
   * Getter for backward compatibility.
   * @private
   */
  get awid() {
    return this.getAwid();
  }

  async _isMongoStarted(connectionUri) {
    let match = null;
    if ((match = connectionUri.match(/^mongodb:\/\/([^:\/]+)(:[^\/]+)?(\/[^\?]+)?/))) {
      let host = match[1];
      let port = (match[2] || ":27017").substr(1);

      return new Promise((resolve, reject) => {
        let socket = new Socket();
        socket.on("error", function() {
          resolve(false);
        });
        socket.connect(port, host, function() {
          socket.end();
          resolve(true);
        });
      });
    } else {
      return false;
    }
  }
}

module.exports = new TestHelper();
