"use strict";

const Path = require("path");
const Util = require("util");
const Fs = require("fs");
const fsReadFile = Util.promisify(Fs.readFile);
const {UriBuilder} = require("uu_appg01_core-uri");
const {LoggerFactory} = require("uu_appg01_core-logging");
const {InvalidCredentials, UntrustedCredentials, AuthenticationError} = require("uu_appg01_core-authentication");
const {AuthenticationService} = require("uu_appg01_oidc");
const {ClientCredentialsProvider, Base64} = require("uu_appg01_oidc").Internal;
const OidcModel = require("../models/oidc-model.js");

const CALLBACK_PATH = "oidc/callback";
const SESSION_COOKIE = "uu.app.at";

/**
 * Controller implementing endpoints for OIDC interaction.
 */
class OidcController {

  constructor() {
    this._logger = LoggerFactory.get("uuapp.oidc.appserver.OidcController");
    // autobind
    this.initOidcClient = this.initOidcClient.bind(this);
    this.setAllowedRedirects = this.setAllowedRedirects.bind(this);
    this.getAllowedRedirects = this.getAllowedRedirects.bind(this);
    this.callback = this.callback.bind(this);
    this.refresh = this.refresh.bind(this);
    this.logout = this.logout.bind(this);
    this.introspect = this.introspect.bind(this);
    this.getClientId = this.getClientId.bind(this);
  }

  /**
   * Initializes OidcClient (generates private/public key pair for private key JWT authentication,
   * stores public key as OidcClient credentials and updates OidcClient with default redirect uri).
   */
  async initOidcClient(ucEnv) {
    return OidcModel.initOidcClient(ucEnv.getUri(), ucEnv.getDtoIn(), ucEnv.getSession());
  }

  /**
   * Stores set of allowed redirect uris to OidcClient registered for given AWID/ASID.
   */
  async setAllowedRedirects(ucEnv) {
    return OidcModel.setAllowedRedirects(ucEnv.getUri(), ucEnv.getDtoIn(), ucEnv.getSession());
  }

  /**
   * Loads set of allowed redirect uris from OidcClient registered for given AWID/ASID.
   */
  async getAllowedRedirects(ucEnv) {
    return OidcModel.getAllowedRedirects(ucEnv.getUri(), ucEnv.getDtoIn(), ucEnv.getSession());
  }

  /**
   * Returns callback HTML. In case of authorization code flow
   * also obtains access_token and stores it to cookie.
   */
  async callback(ucEnv) {
    let authorizationCode = ucEnv.getDtoIn().code;
    let response = ucEnv.getResponse();
    if (authorizationCode) {
      let uri = ucEnv.getUri();
      try {
        let scope = uri.getBaseUri().toString();
        let redirectUriCheck = this._getRedirectUri(uri).split("?")[0];
        let credentials = {code: authorizationCode, redirect_uri: redirectUriCheck};
        let session = await AuthenticationService.authenticate(credentials, scope);
        this._createSessionCookie(uri, session, response);
      } catch (e) {
        this._logger.error("Unable to get access token via authorization code.", e);
        let redirectUri = this._getRedirectUri(uri);
        redirectUri = this._addUriParameters(redirectUri, {error: this._getErrorCode(e)});
        redirectUri = this._addUriParameters(redirectUri, {error_description: e.message});
        response.setStatus(302);
        response.setHeader('Location', redirectUri);
        // Delete application session (we might be in callback after refresh)
        this._deleteSessionCookie(uri, response);
        return null;
      }
    } else if (ucEnv.getDtoIn().error) {
      // In case of error, delete existing session
      let uri = ucEnv.getUri();
      this._deleteSessionCookie(uri, response);
    }
    let callback = await fsReadFile(Path.join(__dirname, "callback.html"), "utf8");
    response.setContentType("text/html");
    response.setBody(callback);
    return null;
  }

  /**
   * Refreshes access_token stored in session cookie
   * (via invocation of code based flow authorization).
   */
  async refresh(ucEnv) {
    let response = ucEnv.getResponse();
    let uri = ucEnv.getUri();
    let session = ucEnv.getSession();
    try {
      let scope = uri.getBaseUri().toString();
      let redirectUri = this._getRedirectUri(uri);
      let serviceName = session.getServiceName();
      let oauthClient = session._oauthClient;
      let clientCredentials = await ClientCredentialsProvider.getClientCredentials(serviceName);
      let acrValues = ucEnv.getDtoIn().acr_values || session.getAuthenticationLevelOfAssurance();
      let authzCodeUri = await oauthClient.getAuthorizationUri("code", redirectUri, clientCredentials, acrValues, scope);
      authzCodeUri = this._addUriParameters(authzCodeUri, uri.getParameters());
      authzCodeUri = this._addUriParameters(authzCodeUri, {prompt: "none"});
      response.setStatus(302);
      response.setHeader('Location', authzCodeUri);
    } catch (e) {
      this._logger.error("Unable to prolong session.", e);
      let redirectUri = this._getRedirectUri(uri);
      redirectUri = this._addUriParameters(redirectUri, {error: this._getErrorCode(e)});
      redirectUri = this._addUriParameters(redirectUri, {error_description: e.message});
      response.setStatus(302);
      response.setHeader('Location', redirectUri);
      // Delete application session
      this._deleteSessionCookie(uri, response);
    }
    return null;
  }

  /**
   * Ensures revocation of authentication token, deletion of session
   * cookie and ending of session if provided by OIDC server.
   */
  async logout(ucEnv) {
    let response = ucEnv.getResponse();
    let uri = ucEnv.getUri();
    let session = ucEnv.getSession();
    let oauthClient = session._oauthClient;
    this._deleteSessionCookie(uri, response);
    let endSessionUri = await oauthClient.getEndSessionUri();
    let redirectUri = null;
    if (endSessionUri) {
      redirectUri = this._addUriParameters(endSessionUri, uri.getParameters());
      if (uri.getParameters().post_logout_redirect_uri && !uri.getParameters().id_token_hint) {
        let idTokenHint;
        try {
          let scope = endSessionUri.split("?")[0];
          let opts = {callTokenType: "idToken", excludeAuthenticationType: true};
          idTokenHint = await session.getCallToken(scope, opts);
          // In case we created new idToken only for logout, we have to
          // remove it from cache (because it is revoked in oidc server)
          oauthClient.listTokens((tokenKey, grantedToken) => {
            if (grantedToken.id_token == idTokenHint) {
              oauthClient.deleteToken(tokenKey);
              return false;
            }
          });
        } catch (e) {
          this._logger.warn("Unable to provide id_token_hint, using standard token.", e);
          idTokenHint = session._idToken;
        }
        if (idTokenHint) {
          redirectUri = this._addUriParameters(redirectUri, {id_token_hint: idTokenHint});
        }
      }
    } else if (uri.getParameters().post_logout_redirect_uri || uri.getParameters().redirect_uri) {
      redirectUri = uri.getParameters().post_logout_redirect_uri || uri.getParameters().redirect_uri;
    }
    if (redirectUri) {
      response.setHeader('Location', redirectUri);
      response.setStatus(302);
    } else {
      let callback = await fsReadFile(Path.join(__dirname, "callback.html"), "utf8");
      response.setContentType("text/html");
      response.setBody(callback);
    }
    try {
      await session.close();
    } catch (e) {
      this._logger.warn("Revocation of token failed.", e);
    }
    return null;
  }

  /**
   * Returns claims related to current session (which is not available
   * on frontend in case authorization code flow was used).
   */
  async introspect(ucEnv) {
    let session = ucEnv.getSession();
    return session._attributes;
  }

  /**
   * Returns client_id of OidcClient based on server configuration.
   */
  async getClientId(ucEnv) {
    let serviceName = ucEnv.getDtoIn().serviceName || AuthenticationService.getServiceName();
    let clientId = (await ClientCredentialsProvider.getClientCredentials(serviceName)).client_id;
    return {clientId: clientId};
  }

  /**
   * Returns redirect URI based on incoming uri (and it parameters).
   * @private
   */
  _getRedirectUri(uri) {
    let callbackUri = null;
    let state = uri.getParameters().state;
    if (state) {
      state = JSON.parse(Base64.urlSafeDecode(state));
      callbackUri = state.redirectUri;
    }
    if (!callbackUri) {
      let baseUri = uri.getBaseUri();
      callbackUri = UriBuilder.parse(baseUri);
      callbackUri.setUseCase(CALLBACK_PATH);
      callbackUri = callbackUri.toString();
    }
    return callbackUri;
  }

  /**
   * Appends given parameters to URI (UriBuilder cannot be used, because
   * URI we are appending attributes to might not be valid uuURI).
   * @private
   */
  _addUriParameters(uri, params) {
    uri = `${uri}${(uri.indexOf("?") > -1) ? "&" : "?"}`;
    for (let key in (params || {})) {
      uri += `${key}=${encodeURIComponent(params[key])}&`;
    }
    return uri.slice(0, -1);
  }

  /**
   * Returns error code based on error type.
   * @private
   */
  _getErrorCode(error) {
    let code = error.code;
    if (!code) {
      switch (true) {
        case (error instanceof InvalidCredentials):
          code = "uu-appg01/authentication/invalidCredentials";
          break;
        case (error instanceof UntrustedCredentials):
          code = "uu-appg01/authentication/untrustedCredentials";
          break;
        case (error instanceof AuthenticationError):
          code = "uu-appg01/authentication/unexpectedFailure";
          break;
        default:
          code = "uu-appg01/server/internalServerError";
      }
    }
    return code;
  }

  _createSessionCookie(uri, session, response) {
    let accessToken = session._accessToken;
    let expireAt = session._attributes.exp;
    let value = `${expireAt}.${Base64.urlSafeEncode(accessToken)}`;
    let path = `/${uri.getProduct()}/${uri.getWorkspace()}`;
    let secure = (uri.getScheme() === 'https');
    let cookie = `${SESSION_COOKIE}=${value};path=${path};httponly${secure ? ";secure" : ""}`;
    response.setHeader("Set-Cookie", cookie);
  }

  _deleteSessionCookie(uri, response) {
    let path = `/${uri.getProduct()}/${uri.getWorkspace()}`;
    let secure = (uri.getScheme() === 'https');
    let cookie = `${SESSION_COOKIE}=;path=${path};httponly${secure ? ";secure" : ""};max-age=-1`;
    response.setHeader("Set-Cookie", cookie);
  }

}

module.exports = new OidcController();
