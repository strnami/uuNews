"use strict";

const Crypto = require("crypto");
const {Config} = require("uu_appg01_core-utils");
const {LoggerMDC, LoggerFactory} = require("uu_appg01_core-logging");
const {Perflog} = require("uu_appg01_core-perflog");
const Authn = require("uu_appg01_core-authentication");
const AppServer = require("uu_appg01_core-appserver");
const {AuthenticationService, Session} = require("uu_appg01_oidc");
const {Base64} = require("uu_appg01_oidc").Internal;

const MIDDLEWARE_ORDER = -50;

const PARAM_UNPROTECTED_REGEXP = "uu_app_authentication_unprotected_uri_regexp";
const PARAM_ANONYMOUS_LOGIN = "uu_app_authentication_anonymous_login_enabled";
const PARAM_UNPROTECTED_REGEXP_OLD = "uu_oidc_middleware_unprotected_uri_regexp";
const CALLBACK_PATH = "oidc/callback";
const CLIENT_ID_PATH = "oidc/getClientId";

const DEFAULT_UNPROTECTED_REGEXP = ".^";

const HTTP_AUTHORIZATION_BEARER = "Bearer";
const OAUTH_ACCESS_TOKEN_PARAM = "access_token";
const SESSION_COOKE_REGEX = /uu\.app\.at=([^;,]+)/;
const ANONYMOUS_CREDENTIALS = {"access_code1": "anonymous", "access_code2": "anonymous"};

class AuthenticationMiddleware {

  constructor() {
    this.name = "AppServer Session Middleware";
    this.order = MIDDLEWARE_ORDER;
    let unprotectedRegexp = Config.get(PARAM_UNPROTECTED_REGEXP) || Config.get(PARAM_UNPROTECTED_REGEXP_OLD);
    this._unprotectedRegexp = new RegExp(unprotectedRegexp || DEFAULT_UNPROTECTED_REGEXP);
    this._doAnonymousLogin = Config.hasKey(PARAM_ANONYMOUS_LOGIN) ? Config.getBoolean(PARAM_ANONYMOUS_LOGIN) : true;
    this._logger = LoggerFactory.get("uuapp.oidc.AuthenticationMiddleware");
  }

  async pre(req, res, next) {
    // TODO This should be done in UriParser middleware of uuAppServer
    // (additionally, baseUri alias should be available also on UseCaseContext)
    LoggerMDC.set("baseUriAlias", (req.headers["x-base-uri-alias"] || "").split(";")[0].trim());

    let session;
    if (this._unprotectedRegexp.test(req.path) || req.path.endsWith(CALLBACK_PATH) || req.path.endsWith(CLIENT_ID_PATH)) {
      // log.debug { "UNPROTECTED resource=#{req.url} requested. Skip both: session creation and authentication." }
      session = Session._createEmptySession();
      AppServer.UseCaseContext.setSession(session);
      res.locals.session = session;
      return next();
    } else {
      // log.debug { "PROTECTED resource=#{req.url} requested. Prepare Session, Authenticate and Call." }
      let credentials = this._getToken(req, next);
      if (!credentials && this._doAnonymousLogin) {
        credentials = ANONYMOUS_CREDENTIALS;
      }
      if (credentials) {
        try {
          await Perflog.measureSection("UU_OIDC_INIT_SESSION", async section => {
            try {
              session = await AuthenticationService.authenticate(credentials);
            } catch (e) {
              if (e instanceof Authn.InvalidCredentials) {
                if (typeof credentials === "string") {
                  let tokenInfo;
                  if ((credentials.match(/\./g) || []).length === 2) {
                    // For id_token log only its payload
                    tokenInfo = credentials.split(".")[1];
                  } else {
                    // For access_token log sufix and whole token hash to be able to find token in db
                    tokenInfo = `${credentials.substr(credentials.length - 5)}.${this._sha1(credentials)}`
                  }
                  this._logger.error(`Token rejected: ${tokenInfo}`, e);
                }
                let invalidCredentials = new AppServer.InvalidCredentials(e.message, e);
                invalidCredentials.requireAuthentication("Bearer", await AuthenticationService.getServiceUri());
                throw invalidCredentials;
              } else {
                throw new AppServer.AuthenticationFailure("Authentication failed.", e);
              }
            }
          });
        } catch (e) {
          return next(e);
        }
      } else {
        session = Session._createEmptySession();
      }

      if (session.getAuthenticationId()) {
        LoggerMDC.set("sessionId", session.getAuthenticationId());
      }
      if (session.getIdentity()) {
        LoggerMDC.set("identityId", session.getIdentity().getUuIdentity());
      }
      if (session.getApplicationIdentity()) {
        LoggerMDC.set("clientId", session.getApplicationIdentity().getCode());
      }
      AppServer.UseCaseContext.setSession(session);
      res.locals.session = session;
      return next();
    }
  }

  async onError(error, req, res, next) {
    if (error instanceof Authn.UntrustedCredentials) {
      error = new AppServer.UntrustedCredentials(error.message, error);
      error.requireAuthentication("Bearer", await AuthenticationService.getServiceUri());
    }
    return next(error);
  }

  _getToken(req) {
    let authHeader = req.headers.authorization;
    let token = null;
    if (authHeader && authHeader.indexOf(`${HTTP_AUTHORIZATION_BEARER} `) == 0) {
      //Logger.debug(`Parsing ${OAUTH_ACCESS_TOKEN_PARAM} from header ${HEADER_AUTHORIZATION}="${authHeader}".`);
      token = authHeader.substr(7);
    }
    if (!token) {
      //Logger.debug(`Header ${HEADER_AUTHORIZATION} not found, try to use parameter ${OAUTH_ACCESS_TOKEN_PARAM}.`);
      token = (req.body && req.body[OAUTH_ACCESS_TOKEN_PARAM]) || (req.query && req.query[OAUTH_ACCESS_TOKEN_PARAM]);
    }
    if (!token) {
      //Logger.debug(`Parameter ${OAUTH_ACCESS_TOKEN_PARAM} not found, trying session cookie.`);
      let cookies = req.headers.cookie;
      let match = null;
      if (cookies && (match = cookies.toString().match(SESSION_COOKE_REGEX))) {
        let sessionCookie = match[1];
        let [expireAt, encToken] = sessionCookie.split('.');
        if (expireAt * 1000 > Date.now()) {
          token = Base64.urlSafeDecode(encToken);
        }
      }
    }
    return token;
  }

  _sha1(value) {
    let hash = Crypto.createHash("sha1");
    hash.update(value);
    return hash.digest("hex");
  }

}

module.exports = AuthenticationMiddleware;
