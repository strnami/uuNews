"use strict";

const Path = require("path");
const {Config} = require("uu_appg01_core-utils");
const {Uri, UriBuilder} = require("uu_appg01_core-uri");
const {Validator} = require("uu_appg01_core-validation");
const {LoggerFactory} = require("uu_appg01_core-logging");
const {ValidationHelper, UseCaseError} = require("uu_appg01_core-appserver");
const {AppClient, ApplicationError} = require("uu_appg01_core-appclient");
const {AuthenticationService} = require("uu_appg01_core-authentication");
const ClientCredentialsHandler = require("./client-credentials-handler.js");
const {SysAppConfigModel, SysAppWorkspaceConfigModel} = require("uu_appg01_workspace");
const Errors = require("../errors/oidc-errors.js");

const ASID = Config.get("asid");
const DEFAULT_PROVIDER_NAME = "oidcg02";

class OidcModel {

  constructor() {
    this.logger = LoggerFactory.get("uuapp.oidc.appserver.OidcModel");
    this.validator = Validator.load();
  }

  async initOidcClient(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate("oidcInitOidcClientDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
        dtoIn,
        validationResult,
        `${Errors.InitOidcClient.UC_CODE}unsupportedKeys`,
        Errors.InitOidcClient.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.clientId) {
      dtoIn.clientId = dtoIn.awid;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 2
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(dtoIn.providerName, session);
    } catch (e) {
      // A3
      let params = {providerName: dtoIn.providerName};
      if (dtoIn.providerName === DEFAULT_PROVIDER_NAME) {
        // TODO Temporary solution to suppress excessive errors
        //   caused by oidcg02 not being enabled by default. Should
        //   be removed once oidcg02 is implicitly enabled.
        this.logger.warn("Initialization of OidcClient failed.", e);
        let code = `${Errors.InitOidcClient.UC_CODE}integrationNotEnabled`;
        let message = "Integration with uuOidcg02 is not enabled.";
        ValidationHelper.addWarning(uuAppErrorMap, code, message, params);
        return {uuAppErrorMap};
      } else {
        throw new Errors.InitOidcClient.IntegrationNotEnabled({uuAppErrorMap}, params, e);
      }
    }

    // HDS 3
    let awid = dtoIn.awid;
    if (awid === ASID) {
      try {
        await SysAppConfigModel.getAppConfig(ASID);
      } catch (e) {
        if (e instanceof UseCaseError) {
          throw new Errors.InitOidcClient.AppNotInitialized({uuAppErrorMap}, {asid: ASID}, e);
        }
        throw e;
      }
    } else {
      try {
        await SysAppWorkspaceConfigModel.getConfiguration(awid);
      } catch (e) {
        if (e instanceof UseCaseError) {
          throw new Errors.InitOidcClient.AppWorkspaceNotInitialized({uuAppErrorMap}, {awid}, e);
        }
        throw e;
      }
    }

    // HDS 4
    let clientId = dtoIn.clientId;
    let getClientDtoOut = null;
    try {
      getClientDtoOut = await oidcServerClient.get("oidcClient/get", {clientId});
    } catch (e) {
      // A6
      if (e instanceof ApplicationError) {
        throw new Errors.InitOidcClient.RetrievingOfOidcClientFailed({uuAppErrorMap}, {clientId}, e);
      }
      throw e;
    }
    if (!getClientDtoOut || !getClientDtoOut.oidcClient) {
      // A7
      throw new Errors.InitOidcClient.OidcClientDoesNotExist({uuAppErrorMap}, {clientId});
    }
    let oidcClient = getClientDtoOut.oidcClient;

    // HDS 5
    let defaultRedirectUriBuilder = UriBuilder.parse(uri);
    defaultRedirectUriBuilder.setAwid(awid);
    defaultRedirectUriBuilder.setUseCase("oidc/callback");
    defaultRedirectUriBuilder.clearParameters();
    let defaultRedirectUri = defaultRedirectUriBuilder.toUri().toString();
    let redirectUriList = oidcClient.redirectUriList || [];
    if (!redirectUriList.includes(defaultRedirectUri)) {
      redirectUriList.push(defaultRedirectUri);
    }
    if (redirectUriList.length > 16) {
      // A8
      let message = `Redirect uri list of OidcClient ${clientId} is greater than 16. Default redirect uri ${defaultRedirectUri} was not set. Use oidc/setAllowedRedirects to set required redirects.`;
      let params = {clientId, redirectUri: defaultRedirectUri};
      ValidationHelper.addWarning(uuAppErrorMap, `${Errors.InitOidcClient.UC_CODE}tooManyRedirectUris`, message, params);
      this.logger.error(message);
    } else {
      let updateClientDtoIn = {clientId, redirectUriList};
      try {
        let updateClientDtoOut = await oidcServerClient.post("oidcClient/update", updateClientDtoIn);
        oidcClient = updateClientDtoOut.oidcClient;
      } catch (e) {
        // A9
        throw new Errors.InitOidcClient.UpdateOfOidcClientFailed({uuAppErrorMap}, {clientId}, e);
      }
    }

    // HDS 6
    let keyPair = await ClientCredentialsHandler.generateClientKeyPair();
    let setPublicKeyDtoIn = {clientId, publicKey: keyPair.publicKey};
    let setPublicKeyDtoOut = null;
    try {
      setPublicKeyDtoOut = await oidcServerClient.post("authOidcClient/setPublicKey", setPublicKeyDtoIn);
    } catch (e) {
      // A10
      throw new Errors.InitOidcClient.RegistrationOfPublicKeyFailed({uuAppErrorMap}, {clientId}, e);
    }

    // HDS 7
    try {
      await ClientCredentialsHandler.configureOidcClient(awid, dtoIn.providerName, clientId, keyPair);
    } catch (e) {
      // A11
      throw new Errors.InitOidcClient.StoringOfOidcClientConfigurationFailed({uuAppErrorMap}, {clientId}, e);
    }

    // HDS 8
    let dtoOut = {
      clientId: oidcClient.clientId,
      credentialsId: setPublicKeyDtoOut.credentials.id,
      publicKey: setPublicKeyDtoOut.publicKey,
      uuAppErrorMap: uuAppErrorMap
    };
    return dtoOut;
  }

  async setAllowedRedirects(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate(
        "oidcSetAllowedRedirectsDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
        dtoIn,
        validationResult,
        `${Errors.SetAllowedRedirects.UC_CODE}unsupportedKeys`,
        Errors.SetAllowedRedirects.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 2
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(dtoIn.providerName, session);
    } catch (e) {
      // A3
      let params = {providerName: dtoIn.providerName};
      throw new Errors.SetAllowedRedirects.IntegrationNotEnabled({uuAppErrorMap}, params, e);
    }

    // HDS 3
    let clientId;
    try {
      clientId = await ClientCredentialsHandler.getClientId(dtoIn.awid, dtoIn.providerName);
    } catch (e) {
      // A4
      throw new Errors.SetAllowedRedirects.LoadingOfOidcClientConfigurationFailed({uuAppErrorMap}, e);
    }
    if (!clientId) {
      // A5
      let params = {providerName: dtoIn.providerName};
      throw new Errors.SetAllowedRedirects.NoOidcClientConfigured({uuAppErrorMap}, params);
    }

    // HDS 4
    let getClientDtoOut = null;
    try {
      getClientDtoOut = await oidcServerClient.get("oidcClient/get", {clientId});
    } catch (e) {
      // A6
      throw new Errors.SetAllowedRedirects.RetrievingOfOidcClientFailed({uuAppErrorMap}, {clientId}, e);
    }
    if (!getClientDtoOut || !getClientDtoOut.oidcClient) {
      // A7
      throw new Errors.SetAllowedRedirects.OidcClientDoesNotExist({uuAppErrorMap}, {clientId});
    }
    let oidcClient = getClientDtoOut.oidcClient;

    // HDS 5
    let redirectUriList = dtoIn.redirectUriList || oidcClient.redirectUriList || [];
    let postLogoutUriList = dtoIn.postLogoutUriList || oidcClient.postLogoutUriList || [];
    let updateClientDtoIn = {clientId};
    if (redirectUriList.length > 0) {
      updateClientDtoIn.redirectUriList = redirectUriList;
    }
    if (postLogoutUriList.length > 0) {
      updateClientDtoIn.postLogoutUriList = postLogoutUriList;
    }
    try {
      let updateClientDtoOut = await oidcServerClient.post("oidcClient/update", updateClientDtoIn);
      oidcClient = updateClientDtoOut.oidcClient;
    } catch (e) {
      // A8
      throw new Errors.SetAllowedRedirects.UpdateOfOidcClientFailed({uuAppErrorMap}, {clientId}, e);
    }

    // HDS6
    let dtoOut = {
      clientId: oidcClient.clientId,
      redirectUriList: oidcClient.redirectUriList,
      postLogoutUriList: oidcClient.postLogoutUriList,
      uuAppErrorMap: uuAppErrorMap
    };
    return dtoOut;
  }

  async getAllowedRedirects(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate(
        "oidcGetAllowedRedirectsDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
        dtoIn,
        validationResult,
        `${Errors.GetAllowedRedirects.UC_CODE}unsupportedKeys`,
        Errors.GetAllowedRedirects.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 2
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(dtoIn.providerName, session);
    } catch (e) {
      // A3
      let params = {providerName: dtoIn.providerName};
      throw new Errors.GetAllowedRedirects.IntegrationNotEnabled({uuAppErrorMap}, params, e);
    }

    // HDS 3
    let clientId;
    try {
      clientId = await ClientCredentialsHandler.getClientId(dtoIn.awid, dtoIn.providerName);
    } catch (e) {
      // A4
      throw new Errors.GetAllowedRedirects.LoadingOfOidcClientConfigurationFailed({uuAppErrorMap}, e);
    }
    if (!clientId) {
      // A5
      let params = {providerName: dtoIn.providerName};
      throw new Errors.GetAllowedRedirects.NoOidcClientConfigured({uuAppErrorMap}, params);
    }

    // HDS 4
    let getClientDtoOut = null;
    try {
      getClientDtoOut = await oidcServerClient.get("oidcClient/get", {clientId});
    } catch (e) {
      // A6
      throw new Errors.GetAllowedRedirects.RetrievingOfOidcClientFailed({uuAppErrorMap}, {clientId}, e);
    }
    if (!getClientDtoOut || !getClientDtoOut.oidcClient) {
      // A7
      throw new Errors.GetAllowedRedirects.OidcClientDoesNotExist({uuAppErrorMap}, {clientId});
    }
    let oidcClient = getClientDtoOut.oidcClient;

    // HDS5
    let dtoOut = {
      clientId: oidcClient.clientId,
      redirectUriList: oidcClient.redirectUriList,
      postLogoutUriList: oidcClient.postLogoutUriList,
      uuAppErrorMap: uuAppErrorMap
    };
    return dtoOut;
  }

  async _getOidcServerClient(providerName, session) {
    let authenticationService = AuthenticationService.get(providerName);
    let baseUri = Uri.parse(await authenticationService.getServiceUri()).getBaseUri();
    let verifySsl = Config.getBoolean(`uu_app_oidc_providers_${providerName}_verify_ssl`, false);
    let callToken = await session.getCallToken(baseUri, {useTokenExchange: false});
    let opts = {
      baseUri: baseUri,
      headers: {
        authorization: callToken
      },
      verifySsl: verifySsl == null ? true : verifySsl
    };
    return new AppClient(opts);
  }

}

module.exports = new OidcModel();
